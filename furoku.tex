\chapter{遅延聴覚フィードバックが身体運動に与える影響の調査の資料}
% 付録を掲載する場合，\verb|\chapter|コマンドの前に\verb|\appendix|コマンドを入れてください．
遅延聴覚フィードバックが身体運動に与える影響の調査を行うときに用いた,
研究参加同意書（明治大学生用・明治大学生以外の60歳未満の方用・明治大学生以外の60歳以上の方用）,実験概要説明ボード（60歳の未満の方用・60歳以上の方用），聴力検査手順説明ボード，実験手順説明ボード，音量調整ボードを掲載する．
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{furoku_A/douisyo_meiji.pdf} % 画像の幅をテキストの幅に合わせる
	\caption{研究参加同意書（明治大学生用）}
\end{figure}
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.6]{furoku_A/Douisyo_Not60NotMeiji.pdf}
  \caption{研究参加同意書（明治大学生以外の60歳未満の方用）}
\end{figure}
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.6]{furoku_A/Douisyo_60NotMeiji.pdf}
  \caption{研究参加同意書（明治大学生以外の60歳以上の方用）}
\end{figure}
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{furoku_A/Less60_gaiyou.pdf}
  \caption{実験概要説明ボード（60歳未満の方用）}
\end{figure}
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{furoku_A/MoreThan60_Gaiyou.pdf}
  \caption{実験概要説明ボード（60歳以上の方用）}
\end{figure}
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{furoku_A/MoreThan60_tyouryoku.pdf}
  \caption{聴力検査手順説明ボード}
\end{figure}
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{furoku_A/Less60_Tezyunn.pdf}
  \caption{実験手順説明ボード（60歳未満の方用）}
\end{figure}
\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.4]{furoku_A/Onnryou.pdf}
  \caption{音量調整ボード}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 付録B
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{主観調査におけるアプリケーションのソースコード}
% 開発した主観調査におけるアプリケーションを掲載する．本プログラムは，Microsoft Visual Studio 2022でコンパイルできるソースファイル，ヘッダファイルおよびリソースファイルである．関数の目的別にファイルを分けて作成している．

% \begin{lstlisting}[caption=main.cpp]
% //////////////////////////////////////////
% // main.cpp: WinMain関数・ウィンドウプロージャの定義
% //////////////////////////////////////////

% #include<windows.h>
% #include<stdio.h>
% #include<tchar.h>
% #include<WinUser.h>
% #include<commctrl.h> 
% #include<random>
% #include<string>
% #include<iomanip>
% #include<stdlib.h>
% #include<windowsx.h>
% #include<manipulations.h> // Touch Input用

% /////////////////////////////////////
% /// 自作ヘッダファイルのインクルード
% /////////////////////////////////////
% #include"main.h"
% #include"window.h"
% #include"resource.h"
% #include"file.h"
% #include"UserInfoWindow.h"

% using namespace std;

% /////////
% // pragma
% // 1.コモンコントロール
% // 2.音声再生用
% // 3.ビジュアルスタイルの有効化
% /////////
% #pragma comment(lib, "comctl32.lib")
% #pragma comment(lib, "winmm.lib")
% #pragma comment(linker,"/manifestdependency:\"type='win32' \
%   name='Microsoft.Windows.Common-Controls' \
%   version='6.0.0.0' \
%   processorArchitecture='*' \
%   publicKeyToken='6595b64144ccf1df' \
%   language='*'\"") 

% ///////////
% // 定数
% ///////////
% #define STRLEN 256   // 文字列の最大長
% #define GetMonitorRect(rc)  SystemParametersInfo(SPI_GETWORKAREA,0,rc,0)  // ワークエリア領域の取得
% #define CONBOMAX9 9  // コンボボックスの項目数（Group1～5)
% #define CONBOMAX8 8  // コンボボックスの項目数（Group6～10）
% #define LENSNUMBER 128


% //////////////////////////////
% //グローバル変数の宣言・初期化
% /////////////////////////////
% const char	szWinName[5] = _T("Test");
% static const char   szWinName2[] = _T("テスト");
% HINSTANCE hInst;
% HWND hDlg;
% extern char WindowTitleText[32];
% extern int intCurrentIndex;

% //ButtonEnableFunc()で利用
% bool boolstart;  // true: 「ウィンドウが生成されてから1回以上次へボタンを押した」 false: 「ウィンドウが生成されてからまだ次へボタンを押していない」
% bool ZeroOrNot;  // true: 「変数NumberOfTimesが0である」 false: 「変数NumberOfTimesが0以外である」

% // ファイルに書き込んだか否かの取得
% bool FileWriteInfo;

% //HWND hChildUserInfo;

% // 背景
% extern const HBRUSH BackGround_clear = CreateSolidBrush(RGB(235, 235, 235));
% extern const COLORREF TextBackground = RGB(235, 235, 235);
% const COLORREF ColorEdgeButton = RGB(100, 149, 237);

% // フォントサイズ
% extern int fontsize;   // エディットボックスのフォント
% extern int fontsize2;

% // その他変数
% extern unsigned int NumberOfTimes;          // 実験回数を保持する変数
% char Grade[STRLEN];                      // 評価結果の保存用変数
% extern char GradeSpeak[STRLEN],GradeLate[STRLEN];
% HANDLE hfile;
% extern unsigned int GradeS[STRLEN], GradeL[STRLEN];

% char Result[STRLEN];              // 全評価結果を保持する変数
% short int IndexResult;            // Result[]のインデックス番号 
% extern short int i;               // 評価結果保存用配列のインデックス番号
% extern char temp1[STRLEN];
% char temp3[STRLEN];

% // 読み上げる文章の順番を決めるための操作
% extern int SNumber[LENSNUMBER];
% int* P_SNumber;

% // 座標
% int key_i[2] = { 30, 170 };         
% int NumberTest_i[2] = { 40, 215 };  // 表示させる実験回数の座標

% // ファイルへの出力用変数
% DWORD dwWriteSize;


% // コンボボックス内
% int intTxtLen;
% char* pszBuf;

% ////////////////////
% // RECT構造体変数
% ///////////////////
 
% extern RECT FrameTop, FrameProgTop, FrameCenter;
% extern RECT Frame1;
% extern RECT Frame2;
% extern RECT Frame3;
% extern RECT FrameUserInfo;
% extern RECT FrameComment;
% extern RECT FrameProg;
% extern RECT RectButton1, RectButton2, RectButton3, RectButton4, RectButton11, RectButton22, RectButton33, RectButton44;
% RECT Frame4 = { 30, FrameTop.top + 20 - 2, FrameTop.left + 600 + 2, FrameTop.top + 20 + fontsize + 3+2 , };
% RECT Frame5 = { FrameTop.left - 2, 130 - 2, FrameTop.left + 70+ 2, 130 + fontsize + 3+2 };
% RECT Frame_ReadNumber = { Winsize.left + 30, Frame1.top, Winsize.right - 30 / 2, Frame1.bottom };

% /////////////////////////
% // 子ウィンドウのハンドル
% /////////////////////////
% extern HWND Button1, Button2, Button3, Button4, Button11, Button22, Button33, Button44;
% extern HWND hStaticProg, hStaticProg2, hNumberStatic, latedatacombo, hStaticUserDialog, hDialogUser, hStaticSentence;


% HPEN hpen;
% HBRUSH hbr;
% HFONT hFont1;
% HDC hdc;
% /////////////////////////////////////////
% // プログレスバーで使用するグローバル変数
% /////////////////////////////////////////
% int  _MAX, _MIN, _POS, _TEMP;              // プログレスバーで利用する変数
% char bufferProg[10];                           // ステティックコントロールに設定する文字列を格納
% bool TempMAX;
% bool TempResult = true;

% // メモリデバイスコンテキスト
% HDC  hDCMem, hDCMem4;
% HGDIOBJ hDCMemOld, hDCMemOld4;

% // OwnerDrawButton用
% int selectedButtonID_1 = -1;
% int selectedButtonID_2 = -1;
% bool bBtn1 = false;
% bool bBtn2 = false;
% bool bBtn3 = false;
% bool bBtn4 = false;
% bool bBtn5 = false;
% bool bBtn6 = false;
% bool bBtn7 = false;
% bool bBtn8 = false;

% COLORREF color_Buttonbackground = RGB(73, 135, 242);
% COLORREF color_iniButtonbackground = RGB(218,227,242);
% char szText[50];
% bool ButtonBool = false;
% bool Clicked_1 = false;
% bool Clicked_2 = false;
% /*----------------------------------------------------------------------------------------------------------------------*/
% ////////////////////
% //WinMain関数の定義
% ////////////////////
% int APIENTRY WinMain(_In_ HINSTANCE hThisInst, _In_opt_ HINSTANCE hPrevInst, _In_ LPSTR lpszArgs, _In_ int nWinMode)
% {
% 	HWND		hWnd = NULL;
% 	HWND        hWndNew = NULL;
% 	MSG			uMsg;
	
% 	// クライアント領域のサイズ調整
% 	AdjustWindowRectEx(&Winsize, WS_OVERLAPPEDWINDOW, true, 0);

% 	// Show First Window
% 	CreateNewWindow(hWndNew, hThisInst, Winsize.right - Winsize.left, Winsize.bottom - Winsize.top, nWinMode);

% 	//インスタンスハンドルの保存
% 	hInst = hThisInst;

% 	//メッセージループの生成
% 	while (GetMessage(&uMsg, NULL, 0, 0)) {
% 		// GetMessage()関数の戻り値が0になったら（WM_QUITを受け取ったら）ループを抜ける
% 		TranslateMessage(&uMsg);
% 		DispatchMessage(&uMsg);
% 	}
% 	return((int)uMsg.wParam);
% }

% //////////////////////////////////////
% // ウィンドウプロージャの定義
% //////////////////////////////////////
% LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
% {
% 	short int IGrade;                       
% 	INITCOMMONCONTROLSEX initctrl;      // INITCOMMONCONTROLSEX 構造体変数
% 	PAINTSTRUCT ps;
% 	//HWND hwndButton;
	

% 	switch (uMsg){
% 		//終了処理
% 	case WM_DESTROY:
% 		// 書き込み済みの場合は書き込まない
% 		if (!FileWriteInfo) {
% 			// ファイルのオープン
% 			file_open(hWnd);
% 			// ファイルへの書き込み
% 			WriteFileFunc();
% 			// ファイルのクローズ
% 			CloseHandle(hfile);
% 		}
% 		// 後始末
% 		DeleteObject(hFont);
% 		DeleteObject(hFont1);
% 		DeleteObject(hFont2);
% 		DeleteObject(hFontTitle);
% 		DeleteObject(hpen);
% 		DeleteObject(hbr);
% 		SelectObject(hDCMem, hDCMemOld);
% 		SelectObject(hDCMem4, hDCMemOld4);
% 		DeleteDC(hDCMem);
% 		DeleteDC(hDCMem4);
		
% 		//DeleteObject(hBrush); // オーナードローボタンで使用

% 		// WM_QUITをメッセージキューにポスト
% 		PostQuitMessage(0);
% 		return 0;

% 	case WM_CREATE:
% 		P_SNumber = SNumber;                         // 読み上げる文章の番号を格納する配列

% 		// INITCOMMONCONTROLSEX 構造体の初期化
% 		memset(&initctrl, 0, sizeof(initctrl));
% 		initctrl.dwSize = sizeof(initctrl); // INITCOMMONCONTROLSEX構造体のサイズ
% 		initctrl.dwICC = ICC_WIN95_CLASSES; // コモンコントロールクラスの指定（プログレスバー）
% 		InitCommonControlsEx(&initctrl);    // 使用するコントロールクラスの登録

% 		// 画面中央にウィンドウを移動
% 		DesktopCenterWindow(hWnd);

% 		// 初期化処理
% 		WM_CREATE_Func(hWnd, lParam);
	
% 		break;

% 	case WM_CTLCOLORSTATIC:
% 		return (SetCtlColor(wParam, lParam));
	
% 	case WM_TOUCH:
% 		OnTouch(hWnd, wParam, lParam);
% 		break;


% 	case WM_PAINT:
% 	{
% 		hdc = BeginPaint(hWnd, &ps);
% 		// メモリDCからDCへコピー
% 		BitBlt(ps.hdc,
% 			ps.rcPaint.left, ps.rcPaint.top,
% 			ps.rcPaint.right - ps.rcPaint.left, ps.rcPaint.bottom - ps.rcPaint.top,
% 			hDCMem,
% 			ps.rcPaint.left, ps.rcPaint.top,
% 			SRCCOPY);

% 		// ビットマップ画像
% 		BitBlt(ps.hdc,
% 			110, 90,
% 			ps.rcPaint.right - ps.rcPaint.left, ps.rcPaint.bottom - ps.rcPaint.top,
% 			hDCMem4,
% 			0, 0, SRCCOPY);

% 		RECT rc;
% 		GetClientRect(hWnd, &rc);
% 		int x = rc.right - rc.left;
% 		int y = rc.bottom - rc.top;
		
% 		EndPaint(hWnd, &ps);

% 	}
% 		return 0;

% 	case WM_ERASEBKGND:
% 		// 何も処理しない(画面のちらつき防止）
% 		return 1;
% 		break;

% 	case WM_COMMAND:
% 		CommandFunc(hWnd, wParam, lParam, uMsg, hdc);
% 		break;

% 	case WM_DRAWITEM:
% 	{
% 		LPDRAWITEMSTRUCT pdis = (LPDRAWITEMSTRUCT)lParam;
	
% 		switch(pdis->CtlID)
% 		{
% 		case ID_BUTTON1:
% 			OnDrawItem(bBtn1, pdis->hDC, pdis->rcItem, pdis->hwndItem);
% 			break;

% 		case ID_BUTTON2:
% 			OnDrawItem(bBtn2, pdis->hDC, pdis->rcItem, pdis->hwndItem);
% 			break;

% 		case ID_BUTTON3:
% 			OnDrawItem(bBtn3, pdis->hDC, pdis->rcItem, pdis->hwndItem);
% 			break;

% 		case ID_BUTTON4:
% 			OnDrawItem(bBtn4, pdis->hDC, pdis->rcItem, pdis->hwndItem);
% 			break;

% 		case ID_BUTTON11:
% 			OnDrawItem(bBtn5, pdis->hDC, pdis->rcItem, pdis->hwndItem);
% 			break;

% 		case ID_BUTTON22:
% 			OnDrawItem(bBtn6, pdis->hDC, pdis->rcItem, pdis->hwndItem);
% 			break;

% 		case ID_BUTTON33:
% 			OnDrawItem(bBtn7, pdis->hDC, pdis->rcItem, pdis->hwndItem);
% 			break;

% 		case ID_BUTTON44:
% 			OnDrawItem(bBtn8, pdis->hDC, pdis->rcItem, pdis->hwndItem);
% 			break;

% 		default:
% 			return(TRUE);
% 		}
% 	}
% 	return(TRUE);

% 	case WM_CHAR:
% 		switch (wParam) {
% 		case VK_ESCAPE:
% 			PostQuitMessage(0);
% 			break;

% 		case '1':
% 			//PlaySound(TEXT("whistle.wav"), NULL, SND_FILENAME);
% 			// 入力キーの保存
% 			IGrade = 1;
% 			Grade[i] = '1';
% 			i++;
% 			// 実験回数の更新
% 			NumberOfTimes++;
% 			CountNumberFunc(NumberOfTimes);
% 			break;

% 		case '2':
% 			//PlaySound(TEXT("summernight.wav"), NULL, SND_FILENAME);
% 			// 入力キーの保存
% 			IGrade = 2;
% 			Grade[i] = '2';
% 			i++;
% 			//実験回数の更新と表示
% 			NumberOfTimes++;
% 			CountNumberFunc(NumberOfTimes);
% 			break;

% 		case '3':
% 			// 入力キーの保存
% 			IGrade = 3;
% 			Grade[i] = '3';
% 			i++;
% 			//実験回数の更新と表示
% 			NumberOfTimes++;
% 			CountNumberFunc(NumberOfTimes);
% 			break;

% 		case '4':
% 			// 入力キーの保存
% 			IGrade = 4;
% 			Grade[i] = '4';
% 			i++;
% 			// 実験回数の更新と表示
% 			NumberOfTimes++;
% 			CountNumberFunc(NumberOfTimes);
% 			break;

% 		case 0x08: // バックスペース
% 			NumberOfTimes--;                        // 入力回数の更新
% 			hdc = GetDC(hWnd);
% 			CancelFunc(hWnd, hdc, NumberOfTimes);
% 			SetNumber(P_SNumber, NumberOfTimes); // 文章の番号の決定
% 			DispNumberSentence(hdc);                    // 文章の番号の表示
% 			ReleaseDC(hWnd, hdc);
% 			break;

% 		default:
% 			MessageBox(hWnd, "1, 2, 3, 4いずれかのキーを押してください。", NULL, MB_OK | MB_ICONWARNING);
% 			break;
% 		}
% 		return 0;

% 	case WM_KEYUP:
% 		// 何らかのキーが押されたときに発生するイベント
% 		break;

% 	case WM_KEYDOWN:
% 		switch (wParam) {
% 			// Enterを押すと
% 		case VK_RETURN:
% 			// 出力先ファイルが既に開かれていたとき、注意
% 			//WarningFileOpen(hWnd);
% 			if (MessageBox(hWnd, "終了しますか？", "終了確認", MB_YESNO | MB_ICONQUESTION) == IDYES) {
% 				DestroyWindow(hWnd);
% 			}
% 			return 0;
% 		}
% 		break;
 
% 	case WM_CLOSE:
% 		// 出力先ファイルが既に開かれていたとき、注意
% 		//WarningFileOpen(hWnd);
% 		if (MessageBox(hWnd, (LPCSTR)"終了しますか？", (LPCSTR)"終了確認", MB_YESNO | MB_ICONQUESTION) == IDYES) {
% 			DestroyWindow(hWnd);
% 		}
% 		break;

% 	default:
% 		// ボタンの有効・無効の切り替え
% 		ButtonEnableFunc();
% 		return (DefWindowProc(hWnd, uMsg, wParam, lParam));
	
% 	}
% 	return(0);  
% }


% /////////////////////
% // オーナーボタンの描画
% /////////////////////
% bool OnDrawItem(bool bBtn, HDC hDC, RECT rcItem, HWND hwndItem) {

% 	HBRUSH hBrush_ini = (HBRUSH)CreateSolidBrush(color_iniButtonbackground);
% 	HBRUSH hBrush = CreateSolidBrush(RGB(73, 135, 242));

% 	FillRect(hDC, &rcItem, hBrush_ini);
% 	DrawEdge(hDC, &rcItem, EDGE_RAISED, BF_RECT);
% 	GetWindowText(hwndItem, szText, 50);
% 	// Draw Text on Button
% 	SetTextColor(hDC, RGB(0, 0, 0));
% 	SetBkColor(hDC, color_iniButtonbackground);
% 	DrawText(hDC, szText, -1, &rcItem, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

% 	if (bBtn) {
% 		FillRect(hDC, &rcItem, hBrush);
% 		DrawEdge(hDC, &rcItem, EDGE_SUNKEN, BF_RECT);
% 		GetWindowText(hwndItem, szText, 50);
% 		// Draw Text on Button
% 		SetTextColor(hDC, RGB(255, 255, 255));
% 		SetBkColor(hDC, color_Buttonbackground);
% 		DrawText(hDC, szText, -1, &rcItem, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
% 	}

% 	// clean object
% 	DeleteObject(hBrush_ini);
% 	DeleteObject(hBrush);

% 	return true;
% }

% /////////////////////////
% // ボタンの有効化・無効化
% /////////////////////////
% bool ButtonEnableFunc() {

% 	// ボタンの有効化
% 	if (!boolstart) {
% 		 //一度有効化したら終了まで有効状態
% 		if (strMenLady) {
% 			EnableWindow(hReserch, TRUE);
% 			boolstart = true;
% 		}
% 	}
% 	else if (!ZeroOrNot) {
% 		if (NumberOfTimes > 0) {
% 			EnableWindow(hCancel, TRUE);
% 			// 一度有効化したら次に無効状態になるまで有効化しない
% 			ZeroOrNot = true;
% 		}
% 	}
% 	else if ((NumberOfTimes == 0)) {
% 		// 0になったら無効化する
% 		EnableWindow(hCancel, FALSE);
% 		ZeroOrNot = false;
% 	}
% 	else if(NumberOfTimes == _MAX * 2){
% 		// 終了後にボタンを無効化
% 		EnableWindow(hCancel, FALSE);
% 		EnableWindow(Button1, FALSE);
% 		EnableWindow(Button2, FALSE);
% 		EnableWindow(Button3, FALSE);
% 		EnableWindow(Button4, FALSE);
% 		EnableWindow(Button11, FALSE);
% 		EnableWindow(Button22, FALSE);
% 		EnableWindow(Button33, FALSE);
% 		EnableWindow(Button44, FALSE);
% 		EnableWindow(hReserch, FALSE);
% 		EnableWindow(hNext, FALSE);
% 	}
% 	return true;
% }

% //////////////////////////////
% // WM_CREATEメッセージの定義
% //////////////////////////////
% bool WM_CREATE_Func(HWND hWnd, LPARAM lParam) {
% 	// グローバル変数の初期化
% 	NumberOfTimes = 0;                    // 実験回数を保存する変数
% 	i = 0;                                // 評価結果を保存する配列のインデックス
% 	// 子ウィンドウ作成
% 	//ComboboxFunc(hWnd, lParam);           // 遅延時間設定用
% 	ReserchStartFunc(hWnd, lParam);       // 実験開始ボタン
% 	CreateOwnerDrawButton(hWnd, lParam);  // 評価結果入力用ボタン
% 	CreateProgressBar(hWnd, 40, lParam);  // プログレスバーの作成
% 	//プログレスバーの設定
% 	ChangeProgBarMAX(intCurrentIndex);
% 	// 読み上げる文章の順番を決定									  
% 	Getarray(P_SNumber, 10);
% 	// メモリデバイスコンテキスト描画の事前準備
% 	GetWindowMemDCFunc(hWnd);
% 	// メモリデバイスコンテキストへの描画
% 	PaintFunc(hWnd);
% 	// フォントの適用
% 	FontFunc();                        
% 	return true;

% }

% //////////////////////////////////////////////////
% // メモリデバイスコンテキスト描画の事前準備
% //////////////////////////////////////////////////
% bool GetWindowMemDCFunc(HWND hWnd) {

% 	HDC hDC;
% 	HBITMAP hBitmap, hBitmap4;
% 	BITMAP bitmap4{};
	
% 	//デバイスコンテキストの取得
% 	hDC = GetDC(hWnd);
% 	// メモリデバイスコンテキストの取得
% 	hDCMem = CreateCompatibleDC(hDC);
% 	hDCMem4 = CreateCompatibleDC(hDC);
% 	// ビットマップハンドルの取得
% 	hBitmap = CreateCompatibleBitmap(hDC, Winsize.right, Winsize.bottom);
% 	hBitmap4 = LoadBitmap(GetModuleHandle(NULL),//(HINSTANCE)GetWindowLongPtr(hWnd, GWL_HINSTANCE),
% 		MAKEINTRESOURCE(IDB_BITMAP3));
% 	// ビットマップ画像のサイズ取得
% 	GetObject(hBitmap4, sizeof(BITMAP), &bitmap4);
% 	// デバイスコンテキストの解放（メモリデバイスコンテキストを取得するためだけに使うからもう不要）
% 	ReleaseDC(hWnd, hDC);
% 	// メモリDCにビットマップを割りつけ
% 	hDCMemOld = SelectObject(hDCMem, hBitmap);
% 	hDCMemOld4 = SelectObject(hDCMem4, hBitmap4);
% 	// ビットマップの削除（ビットマップはメモリデバイスコンテキストの情報を設定するためだけに使うからもう不要）
% 	DeleteObject(hBitmap);
% 	DeleteObject(hBitmap4);

% 	return true;
% }

% //////////////////////////////////////////
% // メモリデバイスコンテキストへの描画
% //////////////////////////////////////////
% bool PaintFunc(HWND hWnd) {

% 	HRGN hRgn;// , hRgn1, hRgn2, hRgn3;

% 	// フォントの定義
% 	hFont1 = CreateFont(
% 		fontsize2, 0, 0, 0,
% 		FW_MEDIUM,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));
% 	//
% 	// ウィンドウの背景の設定
% 	hRgn = CreateRectRgn(Winsize.left, Winsize.top, Winsize.right, Winsize.bottom);
% 	FillRgn(hDCMem, hRgn, (HBRUSH)CreateSolidBrush(RGB(255,255,255)));
% 	FillRect(hDCMem, &FrameProgTop, (HBRUSH)CreateSolidBrush(RGB(70, 130, 180)));
% 	FillRect(hDCMem, &FrameBottom, (HBRUSH)CreateSolidBrush(RGB(70, 130, 180)));
% 	FillRect(hDCMem, &FrameCenter, BackGround_clear);
% 	/*hRgn1 = CreateRectRgn(FrameBottom.left - 30, FrameBottom.bottom - 64, FrameBottom.right + 30, FrameBottom.bottom);
% 	hRgn2 = CreateRectRgn(0, 0, 30, Winsize.bottom - (FrameBottom.bottom - FrameBottom.top + 5));
% 	hRgn3 = CreateRectRgn(Winsize.right - 30, 0, Winsize.right, Winsize.bottom - (FrameBottom.bottom - FrameBottom.top + 5));*/
% 	//FillRgn(hDCMem, hRgn1, (HBRUSH)CreateSolidBrush(RGB(155,169,194)));
% 	/*FillRgn(hDCMem, hRgn2, (HBRUSH)CreateSolidBrush(RGB(22, 33, 77)));
% 	FillRgn(hDCMem, hRgn3, (HBRUSH)CreateSolidBrush(RGB(22, 33, 77)));*/
% 	DeleteObject(hRgn);
% 	//DeleteObject(hRgn1);
% 	/*DeleteObject(hRgn2);
% 	DeleteObject(hRgn3);*/
% 	// 文字列の背景の設定
% 	SetBkColor(hDCMem, TextBackground);
% 	// フォントの適用
% 	SelectObject(hDCMem, hFont1);
	
% 	// 枠線
% 	DrawEdge(hdc, &FrameBottom, EDGE_RAISED, BF_TOP);

% 	return true;
% }
% ///////////////////////////////
% // WM_COMMANDメッセージの定義
% ///////////////////////////////
% bool CommandFunc(HWND hWnd, WPARAM wParam, LPARAM lParam, UINT uMsg, HDC hdc) {

% 	int MsgResult;
	
% 	switch (LOWORD(wParam)){
% 	case ID_BUTTON1:
% 		GradeS[i] = 1;
% 		Clicked_1 = true;
% 		bBtn1 = true;
% 		bBtn2 = false;
% 		bBtn3 = false;
% 		bBtn4 = false;
% 		InvalidateRect(hWnd, &FrameCenter, FALSE);
% 		//SendMessage(hWnd, WM_DRAWITEM, (WPARAM)0, (LPARAM)&dis);
% 		break;

% 	case ID_BUTTON2:
% 		GradeS[i] = 2;
% 		Clicked_1 = true;
% 		bBtn1 = false;
% 		bBtn2 = true;
% 		bBtn3 = false;
% 		bBtn4 = false;
% 		InvalidateRect(hWnd, &FrameCenter, TRUE);
% 		break;

% 	case ID_BUTTON3:
% 		GradeS[i] = 3;
% 		Clicked_1 = true;
% 		bBtn1 = false;
% 		bBtn2 = false;
% 		bBtn3 = true;
% 		bBtn4 = false;
% 		InvalidateRect(hWnd, &FrameCenter, TRUE);
% 		break;

% 	case ID_BUTTON4:
% 		GradeS[i] = 4;
% 		Clicked_1 = true;
% 		bBtn1 = false;
% 		bBtn2 = false;
% 		bBtn3 = false;
% 		bBtn4 = true;
% 		InvalidateRect(hWnd, &FrameCenter, TRUE);
% 		break;

% 	case ID_BUTTON11:
% 		GradeL[i] = 1;
% 		Clicked_2 = true;
% 		bBtn5 = true;
% 		bBtn6 = false;
% 		bBtn7 = false;
% 		bBtn8 = false;
% 		InvalidateRect(hWnd, &FrameCenter, TRUE);
% 		break;

% 	case ID_BUTTON22:
% 		GradeL[i] = 2;
% 		Clicked_2 = true;
% 		bBtn5 = false;
% 		bBtn6 = true;
% 		bBtn7 = false;
% 		bBtn8 = false;
% 		InvalidateRect(hWnd, &FrameCenter, TRUE);
% 		break;

% 	case ID_BUTTON33:
% 		GradeL[i] = 3;
% 		Clicked_2 = true;
% 		bBtn5 = false;
% 		bBtn6 = false;
% 		bBtn7 = true;
% 		bBtn8 = false;
% 		InvalidateRect(hWnd, &FrameCenter, TRUE);
% 		break;

% 	case ID_BUTTON44:
% 		GradeL[i] = 4;
% 		Clicked_2 = true;
% 		bBtn5 = false;
% 		bBtn6 = false;
% 		bBtn7 = false;
% 		bBtn8 = true;
% 		InvalidateRect(hWnd, &FrameCenter, TRUE);
% 		break;
		
% 	break;

% 	case ID_LATEINI:
% 		LateIniFunc(hWnd, wParam);
% 		break;

	
% 	case ID_ReserchStart:
% 		if (HIWORD(wParam) == BN_CLICKED) {
% 			SetFocus(hWnd);    // 親ウィンドウへフォーカスを移動
% 			// ボタンの有効化
% 			EnableWindow(hNext, TRUE);
% 			EnableWindow(Button1, TRUE);
% 			EnableWindow(Button2, TRUE);
% 			EnableWindow(Button3, TRUE);
% 			EnableWindow(Button4, TRUE);
% 			EnableWindow(Button11, TRUE);
% 			EnableWindow(Button22, TRUE);
% 			EnableWindow(Button33, TRUE);
% 			EnableWindow(Button44, TRUE);
% 			//　遅延時間設定用コンボボックスの無効化
% 			EnableWindow(latedatacombo, false);
% 			MessageBox(hWnd, _T("調査を開始します。"), _T("開始確認"), MB_OK);
% 			// 読み上げる文章の番号を計算し、表示
% 			SetNumber(P_SNumber, NumberOfTimes);
% 			DispNumberSentence(hDCMem);
% 		}
		
% 		break;
    
% 	case ID_NEXTBUTTON:
% 		if (HIWORD(wParam) == BN_CLICKED) {
% 			if (TempMAX) {
% 				MsgResult = MessageBox(hWnd, _T("これで調査は終了です。終了ボタンを押しウィンドウを閉じてください。"), _T("調査終了確認"), MB_OKCANCEL);
% 				if ( MsgResult == IDCANCEL) {
% 					break;
% 				}
% 				else if (MsgResult == IDOK){
% 					hdc = GetDC(hWnd);
% 					NextButtonFunc(hWnd, hdc);
% 					// プログレスバーを更新する
% 					_TEMP = SendMessage(hProg, PBM_STEPIT, 0, 0);
% 					//現在値を取得
% 					_POS = SendMessage(hProg, PBM_GETPOS, 0, 0);
% 					//最大値を超えない場合は1ステップ&テキストに現在値を設定
% 					if (_POS <= _MAX) {
% 						wsprintf(bufferProg, "%d / %d", _POS, _MAX);
% 						SendMessage(hStaticProg, WM_SETTEXT, 0, (LPARAM)bufferProg);
% 						if (_POS == _MAX) {
% 							TempMAX = true;
% 						}
% 					}
% 					const char* bufferSentence = _T("ありがとうございました。");
% 					SendMessage(hStaticSentence, WM_SETTEXT, 0, (LPARAM)bufferSentence);
% 					/////////////////////////
% 					// ファイルに結果を出力
% 					/////////////////////////
% 					file_open(hWnd);          // テキストファイルのオープン
% 					WriteFileFunc();      // ファイルへの書き込み
% 					CloseHandle(hfile);   // ファイルのクローズ
% 					FileWriteInfo = true; // ファイルに書き込み済みであることを知らせる（WM_DESTROYで使用）
% 					break;
					
% 				}
					
% 			}
% 			else {
% 				hdc = GetDC(hWnd);
% 				NextButtonFunc(hWnd, hdc);
% 				if (!TempResult) {
% 					// 正しく回答できていないときは何もしない
% 					break;
% 				}
% 				// プログレスバーを更新する
% 				_TEMP = SendMessage(hProg, PBM_STEPIT, 0, 0);
% 				//現在値を取得
% 				_POS = SendMessage(hProg, PBM_GETPOS, 0, 0);
% 				//最大値を超えない場合は1ステップ&テキストに現在値を設定
% 				if (_POS <= _MAX) {
% 					wsprintf(bufferProg, _T("%d / %d"), _POS, _MAX);
% 					SendMessage(hStaticProg, WM_SETTEXT, 0, (LPARAM)bufferProg);
% 					if (_POS == _MAX) {
% 						TempMAX = true;
% 					}
% 				}
% 				ReleaseDC(hWnd, hdc);
% 				SetFocus(hWnd);
% 			}
% 		}
% 		break;


% 	case ID_CANCEL:
% 		if (HIWORD(wParam) == BN_CLICKED) {
% 			hdc = GetDC(hWnd);
% 			NumberOfTimes = CancelFunc(hWnd, hdc, NumberOfTimes);
% 			SetNumber(P_SNumber, NumberOfTimes);
% 			DispNumberSentence(hdc);
% 			ReleaseDC(hWnd, hdc);
% 			SetFocus(hWnd);   
% 		}

% 		break;

%     // メニューバー
% 	case ID_MENU_MENU1:
% 		//Menu1
% 		SelectFile(hWnd);
% 		break;

% 	case ID_MENU_MENU2:
% 		//Menu2
% 		MessageBox(hWnd, _T("Menu2"), _T("Message Box"), MB_OK);
% 		break;

% 	case ID_ENABLE_ALL_BUTTON:
% 		// 全ボタンの有効化
% 		EnableAllButton();
% 		break;

% 	case ID_GOINI:
% 		if (MessageBox(hWnd, _T("アプリケーションを起動時の状態に戻します。\r\n続行しますか？"), _T("確認"), MB_OKCANCEL | MB_ICONQUESTION) == IDOK) {
% 			API_GOINI(hWnd);
% 			break;
% 		}
% 		break;

% 	case ID_ENABLE_LATEDATACOMBO:
% 		EnableWindow(latedatacombo, TRUE);
% 		break;
% 	/*case ID_BUTTON1:
% 		if (BST_CHECKED == SendMessage(Button1, BM_GETCHECK, 0, 0)) {
% 			GradeS[i] = 1;
% 		}
% 		break;
% 	case ID_BUTTON2:
% 		if (BST_CHECKED == SendMessage(Button2, BM_GETCHECK, 0, 0)) {
% 		    GradeS[i] = 2;
% 	    }
% 		break;
% 	case ID_BUTTON3:
% 		if (BST_CHECKED == SendMessage(Button3, BM_GETCHECK, 0, 0)) {
% 			GradeS[i] = 3;
% 		}
% 		break;
% 	case ID_BUTTON4:
% 		if (BST_CHECKED == SendMessage(Button4, BM_GETCHECK, 0, 0)) {
% 			GradeS[i] = 4;
% 		}
% 		break;
% 	case ID_BUTTON11:
% 		if (BST_CHECKED == SendMessage(Button11, BM_GETCHECK, 0, 0)) {
% 			GradeL[i] = 1;
% 		}
% 		break;
% 	case ID_BUTTON22:
% 		if (BST_CHECKED == SendMessage(Button22, BM_GETCHECK, 0, 0)) {
% 			GradeL[i] = 2;
% 		}
% 		break;
% 	case ID_BUTTON33:
% 		if (BST_CHECKED == SendMessage(Button33, BM_GETCHECK, 0, 0)) {
% 			GradeL[i] = 3;
% 		}
% 		break;
% 	case ID_BUTTON44:
% 		if (BST_CHECKED == SendMessage(Button44, BM_GETCHECK, 0, 0)) {
% 			GradeL[i] = 4;
% 		}
% 		break;*/

% 	case ID_EXIT:
% 			if (MessageBox(hWnd, _T("リセットしますか？"), _T("リセット確認"), MB_YESNO | MB_ICONQUESTION) == IDYES) {
% 				// WM_CREATEメッセージを送信し、ウィンドウの初期化
% 				ResetFunc(hWnd, hInst, szWinName, Winsize.right - Winsize.left, Winsize.bottom - Winsize.top);
% 			}
% 		break;

% 	case ID_QUIT:
% 		if (HIWORD(wParam) == BN_CLICKED) {
% 			// 出力先ファイルが既に開かれていたとき、注意喚起
% 			//WarningFileOpen(hWnd);
% 			if (MessageBox(hWnd, _T("ウィンドウを閉じます。\r\n続行しますか？"), _T("終了確認"), MB_YESNO | MB_ICONQUESTION) == IDYES) {
% 				// WM_DESTORYメッセージの送信
% 				DestroyWindow(hWnd);
% 			}
% 		}
% 		break;
	
% 	default:
% 		break;
% 	}
% 	return true;
% }

% /////////////////////////////////////////////
% // コンボボックスにフォーカスが来たときの処理
% /////////////////////////////////////////////
% bool LateIniFunc(HWND hWnd, WPARAM wParam) {

% 	if (HIWORD(wParam) == CBN_SELCHANGE) {
% 		//コンボボックスで現在選択されている項目のインデックスを取得
% 		intCurrentIndex = SendMessage(GetDlgItem(hWnd, (int)ID_LATEINI), CB_GETCURSEL, 0, 0);
		
% 		// コンボボックスの一覧内の文字列の長さを取得
% 		int intTxtLen = SendMessage(GetDlgItem(hWnd, (int)ID_LATEINI), CB_GETLBTEXTLEN, intCurrentIndex, 0);

% 		if (intTxtLen != CB_ERR) {
% 			char* pszBuf = new char[intTxtLen + 1];
% 			// コンボボックスの一覧から選択した項目の文字列を取得
% 			if (SendMessage(GetDlgItem(hWnd, (int)ID_LATEINI), CB_GETLBTEXT, intCurrentIndex, (LPARAM)pszBuf) != CB_ERR) {
% 				char Path[MAX_PATH + 1];
% 				char settingpath[MAX_PATH + 1]{};
% 				settingpath[0] = '\0';
% 				if (0 != GetModuleFileName(NULL, Path, MAX_PATH)) {
% 					char drive[MAX_PATH + 1], dir[MAX_PATH + 1], fname[MAX_PATH + 1], ext[MAX_PATH + 1];
% 					_splitpath_s(Path, drive, sizeof(drive), dir, sizeof(dir),
% 						fname, sizeof(fname), ext, sizeof(ext));
% 					_stprintf_s(settingpath, MAX_PATH + 1, _T("%s%ssetting.ini"), drive, dir);
% 				}
% 				// iniファイルから選択したキーの遅延時間を取得しlatedataに保存
% 				GetPrivateProfileString(pszBuf, _T("data"), _T("error"), latedata, sizeof(latedata), settingpath);
% 			}
% 			// 遅延グループ名をウィンドウタイトルを保持するchar型配列にコピー
% 			strcpy_s(WindowTitleText, sizeof(WindowTitleText), pszBuf);
% 			delete[] pszBuf;
% 		}

% 		// 親ウィンドウへフォーカスを移動
% 		SetFocus(hWnd);
% 	}
	
% 	return true;
% }

% ////////////////////////////////////////////////////////////////////
% // プログレスバーの最大値を遅延時間設定で選択された項目によって決定
% ////////////////////////////////////////////////////////////////////
% bool ChangeProgBarMAX(int intCurrentIndex) {

% 	char tempProg[10];

% 	if (intCurrentIndex <= 4) {
% 		// プログレスバーの最大値を9に指定
% 		_MAX = CONBOMAX9;
% 		SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, _MAX));
% 		// プログレスバー横のステティックコントロールを更新
% 		sprintf_s(tempProg, sizeof(tempProg), "1 / %d", _MAX);
% 		SendMessage(hStaticProg, WM_SETTEXT, 0, (LPARAM)tempProg);
% 	}
% 	else {
% 		// プログレスバーの最大値を8に指定
% 		_MAX = CONBOMAX8;
% 		SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, _MAX));
% 		// プログレスバー横のステティックコントロールを更新
% 		sprintf_s(tempProg, sizeof(tempProg), "1 / %d", _MAX);
% 		SendMessage(hStaticProg, WM_SETTEXT, 0, (LPARAM)tempProg);
% 	}

% 	return true;
% }

% /////////////////
% // 評価結果を保存
% /////////////////
% bool ResultGrade(char Grade) {

% 	Result[IndexResult] = Grade;
% 	IndexResult += 1;

% 	return true;
% }

% ////////////////
% //実験回数の計算
% ////////////////
% char CountNumberFunc(unsigned int NumberOfTimes) {

% 	short int temp2;

% 	/*if (NumberOfTimes % 2 == 0) { temp2 = NumberOfTimes / 2; }
% 	else                        { temp2 = (NumberOfTimes + 1) / 2; }*/
% 	temp2 = (NumberOfTimes + 2) / 2;
% 	sprintf_s(temp1, sizeof(temp1), "%d回目", temp2);

% 	return char(temp1);
% }

% //////////////////////////////////
% // 乱数生成 　最小値: low, 最大値: high
% /////////////////////////////////
% int GetRandom(unsigned int low, unsigned int high) {
% 	random_device rd;
% 	default_random_engine eng(rd());
% 	uniform_int_distribution<int> distr(low, high);
% 	return distr(eng);
% }
% ///////////////////
% // 配列のシャッフル
% ///////////////////
% int* ShuffleFunc(int* P_SNumber, unsigned int length) {
% 	for (size_t i = 0; i < length; i++){
% 		int r = GetRandom(i, length - 1);
% 		int tmp = P_SNumber[i];
% 		P_SNumber[i] = P_SNumber[r];
% 		P_SNumber[r] = tmp;
% 	}
% 	return P_SNumber;
% }

% /////////////////////////////////////
% // 読み上げる文章の番号を文字列に変換
% /////////////////////////////////////
% char* SetNumber(int* P_SNumber, short int NumberOfTimes) {

% 	int tempSetNumber;
	
% 	// 実験回数の取り込み
% 	/*if (NumberOfTimes % 2 == 0) { temp1 = NumberOfTimes / 2; }
% 	else { temp1 = (NumberOfTimes + 1) / 2; }*/

% 	tempSetNumber = NumberOfTimes / 2;

% 	// int型を文字列に変換
% 	sprintf_s(temp3, sizeof(temp3), "%d番の文章を読み上げてください。", P_SNumber[tempSetNumber]);

% 	return temp3;
% }

% /////////////////////////////
% // 読み上げる文章の番号を取得
% /////////////////////////////
% int* Getarray(int* P_SNumber, unsigned int length) {
% 		// 配列要素の初期化
% 		for (size_t i = 0; i < length; i++) {
% 			P_SNumber[i] = i + 1; 
% 		}
% 	// 配列のシャッフル
% 	P_SNumber = ShuffleFunc(P_SNumber, length);

% 	return P_SNumber;
% }

% /////////////////////////////////////
% // 「戻る」ボタンが押下された時の処理
% /////////////////////////////////////
% unsigned int CancelFunc(HWND hWnd, HDC hdc, unsigned int NumberOfTimes) {

% 	if (i < 1) {
% 		MessageBox(hWnd, "取り消す対象がありません。", NULL, MB_OK | MB_ICONWARNING);
% 	}
% 	else {
% 		// ボタンを元に戻す
% 		bBtn1 = false;
% 		bBtn2 = false;
% 		bBtn3 = false;
% 		bBtn4 = false;
% 		bBtn5 = false;
% 		bBtn6 = false;
% 		bBtn7 = false;
% 		bBtn8 = false;
% 		Clicked_1 = false;
% 		Clicked_2 = false;

% 		InvalidateRect(hWnd, &FrameCenter, TRUE);

% 		i--;                             // 評価結果保存用配列のインデックス更新
% 		NumberOfTimes = NumberOfTimes - 2;
% 		CountNumberFunc(NumberOfTimes);  // 実験回数を文字列に変換
% 		//SendMessage(hNumberStatic, WM_SETTEXT, 0, (LPARAM)temp1);
% 		SetBkColor(hdc, TextBackground); //テキストの背景色
% 		SetTextColor(hdc, RGB(30, 30, 30));

% 		// プログレスバーとステティックコントロールの更新 //
% 		//現在位置を取得
% 		_POS = SendMessage(hProg, PBM_GETPOS, 0, 0); 
% 		if (_POS == _MAX) {
% 			TempMAX = false;
% 		}
% 		// 現在位置を一つずらす
% 		SendMessage(hProg, PBM_SETPOS, (WPARAM)_POS - 1, 0);
% 		// 現在値を取得
% 		_POS = SendMessage(hProg, PBM_GETPOS, 0, 0);
% 		// ステティックコントロール
% 		wsprintf(bufferProg, "%d / %d", _POS, _MAX);
% 		SendMessage(hStaticProg, WM_SETTEXT, 0, (LPARAM)bufferProg);

% 	}
% 	return unsigned int(NumberOfTimes);
% }

% /////////////////////////////////////
% // 「次へ」ボタンが押下された時の処理
% ////////////////////////////////////
% bool NextButtonFunc(HWND hWnd, HDC hdc) {

% 	// ボタンを押していない場合は次に進めない
% 	if (Clicked_1 == false || Clicked_2 == false) {
% 		MessageBox(hWnd, _T("正しく回答できていません。"), _T("エラー"), MB_OK | MB_ICONWARNING);
% 		TempResult = false;
% 		return true;
% 	}

% 	// 実験回数の更新と表示
% 	NumberOfTimes += 2;
% 	i++;                            // 配列のインデックス更新
% 	CountNumberFunc(NumberOfTimes); // 実験回数を文字列に変換
% 	// 実験回数を表示
% 	//SendMessage(hNumberStatic, WM_SETTEXT, 0, (LPARAM)temp1);
% 	SetBkColor(hdc, TextBackground); // テキストの背景色
% 	// 読み上げる文章の番号を表示
% 	SetNumber(P_SNumber, NumberOfTimes);
% 	DispNumberSentence(hdc);
% 	// テキストの色を決定
% 	SetTextColor(hdc, RGB(30, 30, 30));
% 	//TextOut(hdc, NumberTest_i[0], NumberTest_i[1], temp1, lstrlen(temp1));
	
% 	TempResult = true; // ここまできたということは正しく回答できているということ

%     // ボタンを元に戻す
% 	bBtn1 = false;
% 	bBtn2 = false;
% 	bBtn3 = false;
% 	bBtn4 = false;
% 	bBtn5 = false;
% 	bBtn6 = false;
% 	bBtn7 = false;
% 	bBtn8 = false;
% 	Clicked_1 = false;
% 	Clicked_2 = false;

% 	// 再描画要求
% 	InvalidateRect(hWnd, &FrameCenter, TRUE);

% 	return true;
% }

% //////////////////////////////////////
% // 読み上げる文章の番号を表示
% //////////////////////////////////////
% bool DispNumberSentence(HDC hdc) {
% 	SendMessage(hStaticSentence, WM_SETTEXT, 0, (LPARAM)temp3);
% 	return true;
% }

% //////////////////////////
% // WM_CTLCOLORSTATICメッセージの定義
% ///////////////////////////
% long SetCtlColor(WPARAM wParam, LPARAM lParam) {

% 	int i = GetWindowLong((HWND)lParam, GWL_ID);
% 	if (i == 0) return -1;
% 	else {
% 		if((i == ID_STATICPROG) || (i == ID_STATICPROG2)){
% 			SetBkMode((HDC)wParam, TRANSPARENT);
% 			SetTextColor((HDC)wParam, RGB(255, 255, 255));
% 			return (long)CreateSolidBrush(RGB(70, 130, 180));
% 		}
% 		else if (i == ID_STATICSENTENCE) {
% 			SetBkMode((HDC)wParam, TRANSPARENT);
% 			return (long)CreateSolidBrush(RGB(255, 255, 255));
% 		}
% 		else{
% 			SetBkMode((HDC)wParam, TRANSPARENT);
% 			return (long)CreateSolidBrush(TextBackground);
% 		}	
% 	}
% }

% //////////////////////////////////////
% // 指定したRECT構造体変数の枠線の描画（要改善）
% //////////////////////////////////////
% bool MyDrawEdge(HDC hdc, RECT rc) {
	
% 	SelectObject(hdc, hpen);
% 	SelectObject(hdc, hbr);
% 	RoundRect(hdc, rc.left, rc.top, rc.right, rc.bottom, 10, 10);
	

% 	return true;
% }

% /////////////////////////////
% // リセットボタン押下時の処理
% /////////////////////////////
% bool ResetFunc(HWND hWnd, HINSTANCE hThisInst, const char szWinName[], const int nWidth, const int nHeight) {

% 	return true;
% }

% /////////////////
% // 全ボタンの有効化
% ////////////////
% bool EnableAllButton() {

% 	//　ボタンの有効化
% 	EnableWindow(Button1, TRUE);
% 	EnableWindow(Button2, TRUE);
% 	EnableWindow(Button3, TRUE);
% 	EnableWindow(Button4, TRUE);
% 	EnableWindow(Button11, TRUE);
% 	EnableWindow(Button22, TRUE);
% 	EnableWindow(Button33, TRUE);
% 	EnableWindow(Button44, TRUE);
% 	EnableWindow(hReserch, TRUE);
% 	EnableWindow(hNext, TRUE);
% 	EnableWindow(hCancel, TRUE);

% 	return true;
% }

% ///////////////////////////
% // 再起動
% ///////////////////////////
% bool API_GOINI(HWND hWnd) {

% 	TCHAR szPath[MAX_PATH];
% 	GetModuleFileName(NULL, szPath, MAX_PATH);
% 	STARTUPINFO si;
% 	PROCESS_INFORMATION pi;

% 	memset(&si, 0, sizeof(si));
% 	si.cb = sizeof(si);
% 	memset(&pi, 0, sizeof(pi));

% 	if (CreateProcess(szPath, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
% 		CloseHandle(pi.hProcess);
% 		CloseHandle(pi.hThread);
% 		DestroyWindow(hWnd); // WM_DESTROYメッセージを送信
% 	}

% 	return true;
% }

% /////////////////////////////////////////////////
% // メインウィンドウをデスクトップの画面中央に移動
% /////////////////////////////////////////////////
% BOOL DesktopCenterWindow(HWND hWnd)
% {
% 	RECT    rc1{};        // デスクトップ領域
% 	RECT    rc2;        // ウインドウ領域
% 	INT     cx, cy;     // ウインドウ位置
% 	INT     sx, sy;     // ウインドウサイズ

% 	// サイズの取得
% 	GetMonitorRect(&rc1);                            // デスクトップのサイズ
% 	GetWindowRect(hWnd, &rc2);                            // ウインドウのサイズ
% 	sx = (rc2.right - rc2.left);                            // ウインドウの横幅
% 	sy = (rc2.bottom - rc2.top);                            // ウインドウの高さ
% 	cx = (((rc1.right - rc1.left) - sx) / 2 + rc1.left);    // 横方向の中央座標軸
% 	cy = (((rc1.bottom - rc1.top) - sy) / 2 + rc1.top);     // 縦方向の中央座標軸
% 	// 画面中央に移動
% 	return SetWindowPos(hWnd, NULL, cx, cy, 0, 0, (SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER));
% }

% /////////////////
% // 入力結果の分別
% /////////////////
% bool DivideGradeFunc() {

% 	size_t i = 0;

% 	for (size_t j = 0; j < (int)STRLEN / 2; j += 2) {
% 		GradeSpeak[j] = Grade[i];
% 		GradeSpeak[j + 1] = ',';
% 		GradeLate[j] = Grade[i + 1];
% 		GradeLate[j + 1] = ',';
% 		i += 2;
% 	}
% 	return true;
% }

% \end{lstlisting}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%　ここからwindow.cpp
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{lstlisting}[caption=window.cpp]
%   ///////////////////////////////////////////////
% ///window.cpp: 親・子ウィンドウ作成用関数の定義
% //////////////////////////////////////////////

% #include<windows.h>
% #include<tchar.h>
% #include<stdio.h>
% #include <commctrl.h> 
% #include <sstream>
% //////////////////////
% // 自作ヘッダファイル
% /////////////////////
% #include "window.h"
% #include "main.h"
% #include"resource.h"
% #define STRLEN 256

% using namespace std;
% //////////////////////////
% // RECT構造体変数の初期化
% //////////////////////////
% RECT Winsize = {0,0,1100,750};
% RECT FrameMain = {30, 30, Winsize.right - 30, Winsize.bottom - 30};
% RECT FrameUserInfo = {0, 30, Winsize.right, 175};
% RECT FrameComment = {0, 175, Winsize.right, 280};
% RECT FrameProgTop = { Winsize.left, Winsize.top, Winsize.right, 70};
% RECT FrameProg = {0, 280, Winsize.right, 385};
% RECT Frame1 = { 30, 310, Winsize.right - 30, 380 };
% RECT Frame2 = { 30, 420, Winsize.right / 2  - 10, 670 };    // 読み上げるときにしゃべりにくくないか
% RECT Frame3 = { Winsize.right / 2 + 10, 420, Winsize.right - 30,  670 }; // 遅れが気になるか
% RECT FrameTop = { 30, 30, Winsize.right - 30, 300 };
% RECT FrameS = { (FrameTop.left + 100), 100, (FrameTop.left + 100) + 300, 100 + 65 };
% RECT FrameBottom = { 0, Winsize.bottom - 74, Winsize.right,  Winsize.bottom };  // 一番下のボタン
% RECT FrameCenter = { 0, 150, Winsize.right, FrameBottom.top - 5};
% RECT rectS, FrameNumber;
% RECT RectButton1, RectButton2, RectButton3, RectButton4, RectButton11, RectButton22, RectButton33, RectButton44;

% ////////////////
% // 背景色の設定
% ////////////////
% const HBRUSH BackGround_clear = CreateSolidBrush(RGB(235, 235, 235));
% //const HBRUSH BackGround_clear = CreateSolidBrush(LTGRAY_BRUSH);

% // //////////////////////////
% // 子ウィンドウハンドルの宣言
% /////////////////////////////
% HWND CheckMen, CheckLady;      
% HWND hEditName, hEditOld;     // 名前入力エディットボックス用ハンドル    // 年齢入力エディットボックス用ハンドル
% HWND hDialogUser, hStaticDialogUser, hStaticTitle;
% HWND hQuit, hCancel, hReserch, hNext;
% HWND hNumber, hNumberStatic;
% HWND hSpeak, hLate;
% HWND Button1, Button2, Button3, Button4, Button11, Button22, Button33, Button44;
% HWND hProg, hStaticProg, hStaticProg2, latedatacombo, hStaticSentence;

% ////////////////
% // フォント設定
% ////////////////
% HFONT hFont, hFont2, hFontTitle;       
% int fontsize = 30;  
% int fontsize2 = 32;
% int fontsize3 = 42;

% ///////////////////////
% // その他グローバル変数
% ///////////////////////
% short int i;                      // 評価結果保存用配列のインデックス番号
% char temp1[STRLEN];
% extern int _MAX;    // プログレスバーで使用
% char WindowTitleText[32];  // ウィンドウのテキスト
% int intCurrentIndex; // 遅延時間設定用コンボボックスの項目番号

% ////////////////////
% // 親ウィンドウ作成
% ////////////////////
% HWND CreateParentWindow(HWND hWnd, HINSTANCE hThisInst, int nWinMode, const char szWinName[], const int nWidth, const int nHeight)
% {
% 	WNDCLASSEX	wcl{};
% 	//ウィンドウクラスの定義
% 	wcl.cbSize = sizeof(WNDCLASSEX);				//WNDCLASSEX構造体のサイズ
% 	wcl.style = 0;									//ウィンドウクラススタイル
% 	wcl.lpfnWndProc = WndProc;					//ウィンドウ関数
% 	wcl.cbClsExtra = 0;								//ウィンドウクラスのエキストラ
% 	wcl.cbWndExtra = 0;								//ウィンドウインスタンスのエキストラ
% 	wcl.hInstance = hThisInst;						//このプログラムのインスタンスへのハンドル
% 	wcl.hIcon = LoadIcon(NULL, IDI_APPLICATION);	//アイコンへのハンドル
% 	wcl.hCursor = LoadCursor(NULL, IDC_ARROW);		//カーソルへのハンドル
% 	wcl.hbrBackground = BackGround_clear;           //(HBRUSH)GetStockObject(NULL_BRUSH); //背景ブラシへのハンドル
% 	wcl.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1);	//メニュー
% 	wcl.lpszClassName = szWinName;					//ウィンドウクラス名
% 	wcl.hIconSm = LoadIcon(NULL, IDI_WINLOGO);		//スモールアイコンへのハンドル

% 	//ウィンドウクラスの登録
% 	if (!RegisterClassEx(&wcl)) {
% 		return(0);
% 	}
% 	//ウィンドウの生成
% 	hWnd = CreateWindowEx(
% 		0,                      //拡張ウィンドウスタイル
% 		szWinName,				//ウィンドウクラス名
% 		szWinName,				//ウィンドウ名
% 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,	//ウィンドウスタイル
% 		CW_USEDEFAULT,			//x座標
% 		CW_USEDEFAULT,			//y座標
% 		nWidth,			        //幅
% 		nHeight,			    //高さ
% 		HWND_DESKTOP,			//親ウィンドウへのハンドル
% 		NULL,					//メニューへのハンドル
% 		hThisInst,				//このプログラムのインスタンスへのハンドル
% 		NULL					//追加引数
% 	);
% 	if (!hWnd) {
% 		return FALSE;
% 	}

% 	//ウィンドウの表示
% 	ShowWindow(hWnd, nWinMode);
% 	UpdateWindow(hWnd);

% 	// アプリのアイコンを変更
% 	HICON hIcon;
% 	hIcon = (HICON)LoadImage(hThisInst, MAKEINTRESOURCE(IDI_ICON1), IMAGE_ICON, 48, 48, 0);
% 	SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);

% 	// ウィンドウのタイトルを遅延時間のグループ名に設定
% 	if (WindowTitleText[0] != '\0') {
% 		SendMessage(hWnd, WM_SETTEXT, NULL, (LPARAM)WindowTitleText);
% 	}
	
% 	return hWnd;
% }


% //////////////////
% // フォントの適用
% /////////////////
% bool FontFunc() {

% 	hFont = CreateFont(
% 		fontsize, 0, 0, 0,
% 		FW_MEDIUM,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));
% 	hFont1 = CreateFont(
% 		fontsize2, 0, 0, 0,
% 		FW_MEDIUM,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hFont2 = CreateFont(
% 		fontsize3, 0, 0, 0,
% 		FW_BOLD,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hFontTitle = CreateFont(
% 		40, 0, 0, 0,
% 		FW_MEDIUM,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	// To ステティックコントロール
% 	SendMessage(hStaticProg, WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	SendMessage(hStaticProg2, WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	//SendMessage(hStaticTitle, WM_SETFONT, (WPARAM)hFontTitle, MAKELPARAM(false, 0));
% 	SendMessage(hStaticDialogUser, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	SendMessage(hStaticSentence, WM_SETFONT, (WPARAM)hFontTitle, MAKELPARAM(false, 0));
% 	// To 評価結果記録用ボタン
% 	SendMessage(Button1, WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(Button2, WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(Button3, WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(Button4, WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(Button11, WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(Button22, WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(Button33, WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(Button44, WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(hSpeak, WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	SendMessage(hLate, WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	// To 性別選択エディットボックス
% 	SendMessage(CheckMen, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	SendMessage(CheckLady, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	// To 実験回数
% 	SendMessage(hNumberStatic, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	SendMessage(hNumber, WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	// To 下のボタン
% 	SendMessage(hCancel, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	SendMessage(hQuit, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	SendMessage(hReserch, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	SendMessage(hNext, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	// To 個人情報の登録ボタン
% 	SendMessage(hDialogUser, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	// To名前入力エディットボックス
% 	SendMessage(hEditName, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	// To 年齢
% 	SendMessage(hEditOld, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));
% 	// To コンボボックス
% 	SendMessage(latedatacombo, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(false, 0));

	
% 	return true;
% }
% ///////////////////////
% // ダイアログの呼び出し
% ///////////////////////
% bool DialogUserButton(HWND hWnd, LPARAM lParam) {

% 	hDialogUser = CreateWindowEx(
% 		WS_EX_WINDOWEDGE,
% 		_T("BUTTON"),
% 		_T("ここを押す(R)"),
% 		WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON | BS_CENTER,
% 		Winsize.right - 30 - 350 - 260 - 20 + 90, 25 + 30 + 20, 260, 40,
% 		hWnd,
% 		(HMENU)ID_DIALOG_OPEN,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	// ステティックコントロール
% 	hStaticTitle = CreateWindow(
% 		_T("STATIC"),
% 		_T(""),
% 		WS_CHILD | WS_VISIBLE | SS_LEFT,
% 		50, 53, 350, 100,
% 		hWnd, (HMENU)ID_STATIC_DIALOG,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	hStaticDialogUser = CreateWindow(
% 		_T("STATIC"),
% 		_T("ユーザー情報の登録: "),
% 		WS_CHILD | WS_VISIBLE | SS_LEFT,
% 		Winsize.right - 30 - 350 - 260 - 20 + 90, 25 + 20, 260, 30,
% 		hWnd, (HMENU)ID_STATIC_DIALOG,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	return true;
% }

% ///////////////////////
% // プログレスバーの作成
% ///////////////////////
% bool CreateProgressBar(HWND hWnd, int sbHeight, LPARAM lParam) {

% 	//　プログレスバーの作成
% 	hProg = CreateWindowEx(
% 		PBS_SMOOTH,
% 		PROGRESS_CLASS,
% 		NULL,           
% 		WS_CHILD | WS_VISIBLE,        
% 		//130, //Winsize.right - 30 - 425,    // 左下
% 		//Winsize.bottom - 65, 330, sbHeight,   //左下
% 		//FrameProg.right - 440, FrameProg.top + 45, 330, sbHeight,
% 		200, 15, Winsize.right - 400, 40,
% 		//cyVScroll,
% 		hWnd,            
% 		(HMENU)ID_PROG,           
% 		((LPCREATESTRUCT)(lParam))->hInstance,                
% 		NULL          
% 	);

% 	// 現在位置を表示させるステティックコントロール
% 	hStaticProg = CreateWindow(
% 		_T("STATIC"),
% 		_T("1 / 9"),
% 		WS_CHILD | WS_VISIBLE | SS_CENTER,
% 		//490, //Winsize.right - 3 - 100, //左下
% 		//Winsize.bottom - 60, 53, 40,    // 左下
% 		//FrameProg.right - 88, FrameProg.top + 50, 53, 40,
% 		Winsize.right - 185, 20, 53, 30,
% 		hWnd, (HMENU)ID_STATICPROG,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	hStaticProg2 = CreateWindow(
% 		_T("STATIC"),
% 		_T("進行状況:"),
% 		WS_CHILD | WS_VISIBLE | SS_CENTER,
% 		85, 20, 100, 30,
% 		hWnd, (HMENU)ID_STATICPROG2,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	hStaticSentence = CreateWindow(
% 		_T("STATIC"),
% 		_T("開始ボタンを押すとここに文章の番号が表示されます。"),
% 		WS_CHILD | WS_VISIBLE | SS_CENTER,
% 		200, FrameProgTop.bottom + 20, Winsize.right - 400, FrameCenter.top - FrameProgTop.bottom -20,
% 		hWnd, (HMENU)ID_STATICSENTENCE,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL

% 	// プログレスバーの範囲指定
% 	);
% 	SendMessage(hProg, PBM_SETRANGE, (WPARAM)0, MAKELPARAM(0, 9));
% 	// 現在位置を設定  
% 	SendMessage(hProg, PBM_SETPOS, (WPARAM)1, 0);
% 	// 1回の増加分を指定
% 	SendMessage(hProg, PBM_SETSTEP, (WPARAM)1, 0);
% 	//最大値を取得
% 	_MAX = SendMessage(hProg, PBM_GETRANGE, 0, 0);

% 	return true;
% }

% ////////////////////////////
% // 評価結果入力ボタンの作成
% ////////////////////////////
% bool GradeButtonFunc(HWND hWnd, LPARAM lParam) {

% 	/*int height2, width2, height3, width3;

% 	height2 = Frame2.bottom - Frame2.top;
% 	width2 = Frame2.right - Frame2.left;
% 	height3 = Frame3.bottom - Frame3.top;
% 	width3 = Frame3.right - Frame3.left;*/

% 	int Height, Width, WidthHalf, HeightButton, Margin;

% 	Height = (FrameBottom.top - 20) - (FrameCenter.top + 75);
% 	Width = Winsize.right - 60;
% 	WidthHalf = Width / 2 - 10;
% 	Margin = 12;
% 	HeightButton = (Height - 3 * Margin) / 4;

% 	hSpeak = CreateWindow(
% 		_T("STATIC"),
% 		_T("Q1.読み上げたときにしゃべりにくさを感じますか？"),
% 		WS_CHILD | WS_VISIBLE | SS_CENTER,
% 		30, FrameCenter.top + 20, Winsize.right / 2 - 30, 35,
% 		hWnd,
% 		(HMENU)ID_HSPEAK,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	hLate = CreateWindow(
% 		_T("STATIC"),
% 		_T("Q2.読み上げたときに遅れが気になりますか？"),
% 		WS_CHILD | WS_VISIBLE | SS_CENTER,
% 		(Winsize.right - 30) / 2, FrameCenter.top + 20, Winsize.right / 2 - 30, 35,
% 		hWnd,
% 		(HMENU)ID_HLATE,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	Button4 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"),_T("しゃべりにくくない(優)"),WS_VISIBLE | WS_CHILD | WS_GROUP | BS_AUTORADIOBUTTON | WS_DISABLED,
% 		//10, (rectSpeak.bottom - rectSpeak.top) / 16 + 10, (rectSpeak.right - rectSpeak.left) - 15, 40,
% 		//Frame2.left + 50, Frame2.top + (height2) * 2 / 17, (width2) - 55, 40,
% 		30, FrameCenter.top + 75, WidthHalf, HeightButton,
% 		hWnd,(HMENU)ID_BUTTON4,((LPCREATESTRUCT)(lParam))->hInstance,NULL);

% 	Button3 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("良　（しゃべりにくいが気にならない）"), WS_VISIBLE | WS_CHILD | BS_AUTORADIOBUTTON | WS_DISABLED,
% 		//10, (rectSpeak.bottom - rectSpeak.top) * 5 / 16 + 5, (rectSpeak.right - rectSpeak.left) - 15, 40,
% 		//Frame2.left + 50, Frame2.top + (height2) * 6 / 17, (width2) - 55, 40,
% 		30, FrameCenter.top + 75 + HeightButton + Margin, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON3, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button2 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("可　（しゃべりにくい）"), WS_VISIBLE | WS_CHILD | BS_AUTORADIOBUTTON | WS_DISABLED,
% 		//10, (rectSpeak.bottom - rectSpeak.top) * 9 / 16 - 5, (rectSpeak.right - rectSpeak.left) - 15, 40,
% 		//Frame2.left + 50, Frame2.top + (height2) * 10 / 17, (width2) - 55, 40,
% 		30, FrameCenter.top + 75 + 2 * HeightButton + 2 * Margin, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON2, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button1 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("不可（とてもしゃべりにくい）"), WS_VISIBLE | WS_CHILD | BS_AUTORADIOBUTTON | WS_DISABLED,
% 		//10, (rectSpeak.bottom - rectSpeak.top) * 13 / 16 - 10, (rectSpeak.right - rectSpeak.left) - 15, 40,
% 		//Frame2.left + 50, Frame2.top + (height2) * 14 / 17, (width2) - 55, 40,
% 		30, FrameCenter.bottom - 20 - HeightButton, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON1, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button44 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("優　（遅れがまったく分からない）"), WS_VISIBLE | WS_CHILD | WS_GROUP | BS_AUTORADIOBUTTON | WS_DISABLED,
% 		//10, (rectLate.bottom - rectLate.top) / 16 + 10, (rectLate.right - rectLate.left) - 15, 40,
% 		//Frame3.left + 50, Frame3.top + (height3)  * 2 / 17, (width3) - 55, 40,
% 		30 + (Width / 2) + 10, FrameCenter.top + 75, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON44, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button33 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("良　（遅れが分かるが気にならない）"), WS_VISIBLE | WS_CHILD | BS_AUTORADIOBUTTON | WS_DISABLED,
% 		//10, (rectLate.bottom - rectLate.top) * 5 / 16 + 5, (rectLate.right - rectLate.left) - 15, 40,
% 		//Frame3.left + 50, Frame3.top + (height3) * 6 / 17, (width3) - 55, 40,
% 		30 + (Width / 2) + 10, FrameCenter.top + 75 + HeightButton + Margin, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON33, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button22 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("可　（遅れが気になる）"), WS_VISIBLE | WS_CHILD | BS_AUTORADIOBUTTON | WS_DISABLED,
% 		//10, (rectLate.bottom - rectLate.top) * 9 / 16 - 5, (rectLate.right - rectLate.left) - 15, 40,
% 		//Frame3.left + 50, Frame3.top + (height3) * 10 / 17, (width3) - 55, 40,
% 		30 + (Width / 2) + 10, FrameCenter.top + 75 + 2 * HeightButton + 2 * Margin, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON22, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button11 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("不可（遅れがはっきり分かる）"), WS_VISIBLE | WS_CHILD | BS_AUTORADIOBUTTON | WS_DISABLED,
% 		//10, (rectLate.bottom - rectLate.top) * 13 / 16 - 10, (rectLate.right - rectLate.left) - 15, 40,
% 		//Frame3.left + 50, Frame3.top + (height3) * 14 / 17, (width3) - 55, 40,
% 		30 + (Width / 2) + 10, FrameCenter.bottom - 20 - HeightButton, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON11, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	/*if (!SetRect(&RectButton1, Frame2.left + 50 - 5, Frame2.top + (height2) * 4 / 16, 400, Frame2.top + height2 * 4 / 16 + 40)) {
% 		return false;
% 	}*/
% 	RectButton1 = Button_ScreenToClient(hWnd, Button1, RectButton1, 26);
% 	RectButton2 = Button_ScreenToClient(hWnd, Button2, RectButton2, 26);
% 	RectButton3 = Button_ScreenToClient(hWnd, Button3, RectButton3, 26);
% 	RectButton4 = Button_ScreenToClient(hWnd, Button4, RectButton4, 26);

%     RectButton11 = Button_ScreenToClient(hWnd, Button11, RectButton11, RectButton1.right + Margin);
%     RectButton22 = Button_ScreenToClient(hWnd, Button22, RectButton22, RectButton2.right + Margin);
%     RectButton33 = Button_ScreenToClient(hWnd, Button33, RectButton33, RectButton3.right + Margin);
%     RectButton44 = Button_ScreenToClient(hWnd, Button44, RectButton44, RectButton4.right + Margin);

% 	return true;
% }

% // CreateOWnerDrawButton Func
% bool CreateOwnerDrawButton(HWND hWnd, LPARAM lParam) {

% 	int Height, Width, WidthHalf, HeightButton, Margin;

% 	Height = (FrameBottom.top - 20) - (FrameCenter.top + 75);
% 	Width = Winsize.right - 60;
% 	WidthHalf = Width / 2 - 10;
% 	Margin = 12;
% 	HeightButton = (Height - 3 * Margin) / 4;

% 	hSpeak = CreateWindow(
% 		_T("STATIC"),
% 		_T("Q1.読み上げたときにしゃべりにくさを感じますか？"),
% 		WS_CHILD | WS_VISIBLE | SS_CENTER,
% 		30, FrameCenter.top + 20, Winsize.right / 2 - 30, 35,
% 		hWnd,
% 		(HMENU)ID_HSPEAK,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	hLate = CreateWindow(
% 		_T("STATIC"),
% 		_T("Q2.読み上げたときに遅れが気になりますか？"),
% 		WS_CHILD | WS_VISIBLE | SS_CENTER,
% 		(Winsize.right - 30) / 2, FrameCenter.top + 20, Winsize.right / 2 - 30, 35,
% 		hWnd,
% 		(HMENU)ID_HLATE,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	Button4 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("しゃべりにくくない(優)"), WS_VISIBLE | WS_CHILD | WS_GROUP | BS_OWNERDRAW | WS_DISABLED | SS_LEFT,
% 		//10, (rectSpeak.bottom - rectSpeak.top) / 16 + 10, (rectSpeak.right - rectSpeak.left) - 15, 40,
% 		//Frame2.left + 50, Frame2.top + (height2) * 2 / 17, (width2) - 55, 40,
% 		30, FrameCenter.top + 75, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON4, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button3 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("しゃべりにくいが気にならない(良)"), WS_VISIBLE | WS_CHILD | BS_OWNERDRAW | WS_DISABLED,
% 		//10, (rectSpeak.bottom - rectSpeak.top) * 5 / 16 + 5, (rectSpeak.right - rectSpeak.left) - 15, 40,
% 		//Frame2.left + 50, Frame2.top + (height2) * 6 / 17, (width2) - 55, 40,
% 		30, FrameCenter.top + 75 + HeightButton + Margin, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON3, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button2 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("しゃべりにくい(可)"), WS_VISIBLE | WS_CHILD | BS_OWNERDRAW | WS_DISABLED,
% 		//10, (rectSpeak.bottom - rectSpeak.top) * 9 / 16 - 5, (rectSpeak.right - rectSpeak.left) - 15, 40,
% 		//Frame2.left + 50, Frame2.top + (height2) * 10 / 17, (width2) - 55, 40,
% 		30, FrameCenter.top + 75 + 2 * HeightButton + 2 * Margin, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON2, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button1 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("とてもしゃべりにくい(不可)"), WS_VISIBLE | WS_CHILD | BS_OWNERDRAW | WS_DISABLED,
% 		//10, (rectSpeak.bottom - rectSpeak.top) * 13 / 16 - 10, (rectSpeak.right - rectSpeak.left) - 15, 40,
% 		//Frame2.left + 50, Frame2.top + (height2) * 14 / 17, (width2) - 55, 40,
% 		30, FrameCenter.bottom - 20 - HeightButton, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON1, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button44 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("遅れがまったく分からない(優)"), WS_VISIBLE | WS_CHILD | WS_GROUP | BS_OWNERDRAW | WS_DISABLED,
% 		//10, (rectLate.bottom - rectLate.top) / 16 + 10, (rectLate.right - rectLate.left) - 15, 40,
% 		//Frame3.left + 50, Frame3.top + (height3)  * 2 / 17, (width3) - 55, 40,
% 		30 + (Width / 2) + 10, FrameCenter.top + 75, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON44, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button33 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("遅れが分かるが気にならない(良)"), WS_VISIBLE | WS_CHILD | BS_OWNERDRAW | WS_DISABLED,
% 		//10, (rectLate.bottom - rectLate.top) * 5 / 16 + 5, (rectLate.right - rectLate.left) - 15, 40,
% 		//Frame3.left + 50, Frame3.top + (height3) * 6 / 17, (width3) - 55, 40,
% 		30 + (Width / 2) + 10, FrameCenter.top + 75 + HeightButton + Margin, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON33, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button22 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("遅れが気になる(可)"), WS_VISIBLE | WS_CHILD | BS_OWNERDRAW | WS_DISABLED,
% 		//10, (rectLate.bottom - rectLate.top) * 9 / 16 - 5, (rectLate.right - rectLate.left) - 15, 40,
% 		//Frame3.left + 50, Frame3.top + (height3) * 10 / 17, (width3) - 55, 40,
% 		30 + (Width / 2) + 10, FrameCenter.top + 75 + 2 * HeightButton + 2 * Margin, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON22, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	Button11 = CreateWindowEx(WS_EX_WINDOWEDGE, _T("BUTTON"), _T("遅れがはっきり分かる(不可)"), WS_VISIBLE | WS_CHILD | BS_OWNERDRAW | WS_DISABLED,
% 		//10, (rectLate.bottom - rectLate.top) * 13 / 16 - 10, (rectLate.right - rectLate.left) - 15, 40,
% 		//Frame3.left + 50, Frame3.top + (height3) * 14 / 17, (width3) - 55, 40,
% 		30 + (Width / 2) + 10, FrameCenter.bottom - 20 - HeightButton, WidthHalf, HeightButton,
% 		hWnd, (HMENU)ID_BUTTON11, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	return true;
% }

% ///////////////////////////////////////////
% // ボタンの位置座標をクライアント座標に変換
% ///////////////////////////////////////////
% RECT Button_ScreenToClient(HWND hWnd, HWND Button, RECT RectButton, int left) {

% 	// ポイント構造体
% 	POINT P1Button, P2Button;

% 	// ウィンドウ座標をスクリーン座標で取得
% 	GetWindowRect(Button, &RectButton);
% 	P1Button = { RectButton.left, RectButton.top };
% 	P2Button = { RectButton.right, RectButton.bottom };
% 	// スクリーン座標からクライアント座標に変換
% 	ScreenToClient(hWnd, &P1Button);
% 	ScreenToClient(hWnd, &P2Button);
% 	// ウィンドウのクライアントの位置座標を保存
% 	SetRect(&RectButton, left, P1Button.y - 2, P2Button.x + 2, P2Button.y + 2);

% 	return RECT(RectButton);
% }

% ///////////////////////////////////////////////////////
% // 実験開始ボタン・Nextボタン・戻るボタン・終了ボタン
% //////////////////////////////////////////////////////
% bool ReserchStartFunc(HWND hWnd, LPARAM lParam) {

% 	hReserch = CreateWindowEx(
% 		NULL, //WS_EX_WINDOWEDGE,
% 		_T("BUTTON"),
% 		_T("開始(S)"),
% 		WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON | BS_CENTER | WS_DISABLED,
% 		//Winsize.right - 676, (Winsize.bottom - 57), 150, 40,
% 		Winsize.left + 30, (Winsize.bottom - 67), 150, 50,
% 		hWnd,
% 		(HMENU)ID_ReserchStart,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	hCancel = CreateWindowEx(
% 		0, //WS_EX_STATICEDGE,
% 		_T("BUTTON"),
% 		_T("＜前へ戻る(B)"),
% 		WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON | BS_CENTER | WS_DISABLED,
% 		Winsize.right - 150 - 350 - 40 - 100 + 10, (Winsize.bottom - 67), 160, 50,
% 		hWnd,
% 		(HMENU)ID_CANCEL,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	hNext = CreateWindowEx(
% 		WS_EX_WINDOWEDGE,
% 		_T("BUTTON"),
% 		_T("次の文章に進む(N)＞"),
% 		WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON | BS_CENTER | WS_DISABLED,
% 		Winsize.right - 140 - 300 - 30 + 9, (Winsize.bottom - 67), 250, 50,
% 		hWnd,
% 		(HMENU)ID_NEXTBUTTON,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 		);

	

% 	hQuit = CreateWindowEx(
% 		0,//WS_EX_STATICEDGE,
% 		_T("BUTTON"),
% 		_T("終了(E)"),
% 		WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON | BS_CENTER,
% 		Winsize.right - 32 - 160, (Winsize.bottom - 67), 160, 50,
% 		hWnd,
% 		(HMENU)ID_QUIT,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	return true;
% }

% //////////////////////////////////////////////
% // コンボボックス作成, iniファイルの読み込み
% /////////////////////////////////////////////
% bool ComboboxFunc(HWND hWnd, LPARAM lParam) {

% 	stringstream ss, tt;
% 	string s, t;
% 	char   latename[STRLEN], latedata[STRLEN];
% 	latename[0] = '\0';
% 	latedata[0] = '\0';
% 	char Path[MAX_PATH + 1];
% 	char settingpath[MAX_PATH + 1];
% 	settingpath[0] = '\0'; // NULL終端

% 	// 遅延データ設定用コンボボックスの作成
% 	latedatacombo = CreateWindow(
% 		_T("COMBOBOX"),
% 		NULL,
% 		WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST,
% 		Winsize.right - 330,
% 		605,
% 		260,
% 		400,
% 		//30, 130, 340, 400,
% 		hWnd,
% 		(HMENU)ID_LATEINI,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	// 実行ファイルのパスを取得
% 	if (0 != GetModuleFileName(NULL, Path, MAX_PATH)) {
% 		char drive[MAX_PATH + 1], dir[MAX_PATH + 1], fname[MAX_PATH + 1], ext[MAX_PATH + 1];
% 		// ドライブ名, ディレクトリパス名, ファイル名, 拡張子
% 		_splitpath_s(Path, drive, sizeof(drive), dir, sizeof(dir),
% 			fname, sizeof(fname), ext, sizeof(ext));
% 		_stprintf_s(settingpath, MAX_PATH + 1, _T("%s%ssetting.ini"), drive, dir);

% 	}
% 	// iniファイルの読み込み
% 	GetPrivateProfileString(_T("setting"), _T("latedataname"), _T("error"), latename, sizeof(latename), settingpath);

% 	ss << latename;

% 	// 遅延データのキーをコンボボックスに詰めていく
% 	int i = 0;
% 	while (getline(ss, s, ',')) {
% 		char* cstr = new char[s.size() + 1];
% 		char_traits<char>::copy(cstr, s.c_str(), s.size() + 1);
% 		SendMessage(GetDlgItem(hWnd, (int)ID_LATEINI), CB_INSERTSTRING, i, (LPARAM)cstr);
% 		i++;
% 	}

% 	SendMessage(GetDlgItem(hWnd, (int)ID_LATEINI), CB_SETCURSEL, 0, 0);

% 	return true;
% }



% \end{lstlisting}



% \begin{lstlisting}[caption=file.cpp]
% //////////////////////////////////////////////
% // file.cpp: ファイル入出力関係の処理を記述
% /////////////////////////////////////////////

% #include<windows.h>
% #include<tchar.h>
% #include<stdio.h>
% #include<string>
% #include<string.h>
% #include<locale.h>
% //////////////////////
% // 自作ヘッダファイル
% //////////////////////
% #include "window.h"
% #include "main.h"
% #include "file.h"

% using namespace std;

% //////////
% ///定数
% //////////
% #define STRLEN 256
% #define LENSNUMBER 128
% #define FILESIZE 100

% /// <summary>
% /// グローバル変数
% /// ///////////////
% extern HANDLE hfile;                                          // ファイルハンドル
% extern int  _MAX;                                               // 読んだ回数を保持するグローバル変数
% int SNumber[LENSNUMBER];                              // 読んだ文章の番号
% unsigned int NumberOfTimes;                             // 実験回数 * 2
% const char* IpBuffer;                                          // 遅延時間を書き込む際に必要
% char latedata[STRLEN];                                      // 遅延時間
% unsigned int GradeS[STRLEN], GradeL[STRLEN];  // 評価結果
% char GradeSpeak[STRLEN], GradeLate[STRLEN];
% DWORD dWFileSizeByte;                                    // WriteFile()で使用
% std::string fileNameCapture;

% ///////////////////////////////////////
% //　グローバル変数（file.cppでのみ使用）
% ///////////////////////////////////////
% static char FileName[MAX_PATH];             // ユーザーが入力したファイル名


% ///////////////////////
% // ファイルのオープン
% ///////////////////////
% bool file_open(HWND hWnd) {

	

% 	hfile = CreateFile(
% 		FileName,        // ファイルの名前
% 		GENERIC_READ | GENERIC_WRITE,   // 書き込みモード
% 		0,               // 共有モード 
% 		NULL,            // セキュリティ
% 		OPEN_ALWAYS,   // 上書き保存
% 		FILE_ATTRIBUTE_NORMAL,
% 		NULL
% 	);
% 	if (hfile == INVALID_HANDLE_VALUE) {
% 		MessageBox(NULL, _T("ファイルの作成に失敗しました。"), _T("エラー"), MB_OK);
% 		return 1;
% 	}
% 	// ファイルサイズの取得
% 	dWFileSizeByte = GetFileSize(hfile, NULL);

% 	return true;
% }

% // 引数で指定した文字列をファイルへの書き込み
% bool WriteFileStr(LPCSTR strText) {

% 	DWORD dwWriteSize;

% 	WriteFile(hfile, strText, (DWORD)_tcslen(strText), &dwWriteSize, NULL);

% 	return true;
% }

% // 評価結果をファイルへ書き込む
% bool file_write() {

% 	DWORD dwWriteSize;
% 	string GradeS_str, GradeL_str;

% 	//const char* IpBuffer1;
% 	//const char* IpBuffer2;
% 	//// 入力結果を二つに分ける(「しゃべりにくさ」と「遅れが気になるか」）
% 	//DivideGradeFunc();
% 	//IpBuffer1 = GradeSpeak;
% 	//IpBuffer2 = GradeLate;
% 	//
% 	unsigned int tempS = 0;
% 	for (unsigned int item : GradeS) {
% 		if (tempS >= NumberOfTimes / 2) break;
% 		else {
% 			GradeS_str += to_string(item) + ",";
% 			tempS += 1;
% 		}
% 	}
% 	tempS = 0;
% 	for (unsigned int item : GradeL) {
% 		if (tempS >= NumberOfTimes / 2) break;
% 		else {
% 			GradeL_str += to_string(item) + ",";
% 			tempS += 1;
% 		}
% 	}
% 	// ファイルに書き込む
% 	WriteFile(hfile, GradeS_str.data(), GradeS_str.length(), &dwWriteSize, NULL);
% 	//WriteFile(hfile, _T("\r\n"), (DWORD)_tcslen(_T("\r\n")), &dwWriteSize, NULL); // 改行コード
% 	WriteFile(hfile, GradeL_str.data(), GradeL_str.length(), &dwWriteSize, NULL);

% 	return true;
% }

% /////////////////////////////////////
% /// ファイルへの書き込み用関数の定義
% /////////////////////////////////////
% bool WriteFileFunc() {

% 	DWORD dwWriteSize = 0;

% 	// ロケールを日本に設定
% 	setlocale(LC_ALL, "Japanese");

% 	// 指定したファイルが存在した場合
% 	if (dWFileSizeByte > FILESIZE) {
% 		// ファイルを上書きする場合,出力の開始点を現在のファイルの終了位置に設定
% 		SetFilePointer(hfile, 0, NULL, FILE_END);
% 		// 入力結果の書き込み
% 		WriteFileResult(dwWriteSize);
% 	}else {
% 	// 指定したファイルが存在しなかった場合
% 		WriteFile(hfile, _T("ユーザー情報,年齢,性別,文章"), (DWORD)_tcslen(_T("ユーザー情報,年齢,性別,文章")), &dwWriteSize, NULL);
% 		if (_MAX == 9) {
% 			WriteFile(hfile, _T(",,,,,,,,,"), (DWORD)_tcslen(_T(",,,,,,,,,")), &dwWriteSize, NULL);
% 		}
% 		else {
% 			WriteFile(hfile, _T(",,,,,,,,"), (DWORD)_tcslen(_T(",,,,,,,,")), &dwWriteSize, NULL);
% 		}
% 		WriteFile(hfile, _T("遅延時間"), (DWORD)_tcslen(_T("遅延時間")), &dwWriteSize, NULL);
% 		if (_MAX == 9) {
% 			WriteFile(hfile, _T(",,,,,,,,,,"), (DWORD)_tcslen(_T(",,,,,,,,,,")), &dwWriteSize, NULL);
% 		}
% 		else {
% 			WriteFile(hfile, _T(",,,,,,,,,"), (DWORD)_tcslen(_T(",,,,,,,,,")), &dwWriteSize, NULL);
% 		}
% 		WriteFile(hfile, _T("しゃべりにくさ"), (DWORD)_tcslen(_T("しゃべりにくさ")), &dwWriteSize, NULL);
% 		if (_MAX == 9) {
% 			WriteFile(hfile, _T(",,,,,,,,,"), (DWORD)_tcslen(_T(",,,,,,,,,")), &dwWriteSize, NULL);
% 		}
% 		else {
% 			WriteFile(hfile, _T(",,,,,,,,"), (DWORD)_tcslen(_T(",,,,,,,,")), &dwWriteSize, NULL);
% 		}
% 		WriteFile(hfile, _T("遅れ"), (DWORD)_tcslen(_T("遅れ")), &dwWriteSize, NULL);
% 		// 入力結果の書き込み
% 		WriteFileResult(dwWriteSize);
% 	}
% 	// メモリの解放
% 	//free(strTextName);
% 	//free(strTextOld);

% 	return true;
% }

% ////////////////////////
% // 評価結果の書き込み
% ///////////////////////
% bool WriteFileResult(DWORD dwWriteSize) {

% 	// 改行コード
% 	WriteFile(hfile, _T("\r\n"), (DWORD)_tcslen(_T("\r\n")), &dwWriteSize, NULL);
% 	// ハイパーリンクの作成
% 	char data[STRLEN];
% 	std::string NameTemp = _T("ここをクリック");
% 	sprintf_s(
% 		data,
% 		"\"=HYPERLINK(\"\"%s\"\",\"\"%s\"\")\"",
% 	fileNameCapture.c_str(),NameTemp.c_str());
% 	// ファイル名の書き込み
% 	WriteFile(hfile, data, strlen(data), &dwWriteSize, NULL);
% 	// 性別を書き込む
% 	WriteFile(hfile, strMenLady, (DWORD)strlen(strMenLady), &dwWriteSize, NULL);
% 	// 読んだ文章の番号を書き込む 
% 	string array1_str;
% 	unsigned int temp = 0;
% 	for (int item : SNumber) {
% 		if (temp >= NumberOfTimes / 2) break;
% 		else {
% 			array1_str += to_string(item) + ",";
% 			temp += 1;
% 		}
% 	}
% 	WriteFile(hfile, array1_str.data(), array1_str.length(), &dwWriteSize, NULL);
% 	// テキストファイルに遅延時間を書き込む
% 	IpBuffer = latedata;
% 	WriteFile(hfile, IpBuffer, lstrlen(IpBuffer), &dwWriteSize, NULL);
% 	// カンマ
% 	WriteFile(hfile, _T(","), (DWORD)_tcslen(_T(",")), &dwWriteSize, NULL);
% 	// ファイルへ評価結果を書き込む
% 	file_write();

% 	return true;
% }
% //////////////////////////////////////////////
% // [名前を付けて保存]ダイアログボックスの作成
% //////////////////////////////////////////////
% bool SelectFile(HWND hWnd) {


% 	static OPENFILENAME ofn;
% 	memset(&ofn, 0, sizeof(ofn));
% 	memset(&FileName, 0, sizeof(char) * MAX_PATH);

% 	// OPENFILENAME 構造体の初期化
% 	ofn.lStructSize = sizeof(ofn);
% 	ofn.hwndOwner = hWnd;
% 	//ofn.lpstrFilter = _T("Text Files(*.txt)\0*.txt\0All Files(*.*)\0*.*\0\0"); 
% 	ofn.lpstrFilter = _T("CSV Files(*.csv)\0*.csv\0All Files(*.*)\0*.*\0\0");
% 	ofn.lpstrFile = FileName;
% 	ofn.nMaxFile = MAX_PATH;
% 	ofn.lpstrDefExt = _T("csv");
% 	ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST; 
% 	ofn.lpstrTitle = "名前を付けて保存";

% 	if (!GetSaveFileName(&ofn)) {
% 		MessageBox(hWnd, _T("ファイルを作成できませんでした。"), _T("エラー"), MB_OK | MB_ICONERROR);
% 		return false;
% 	}
% 	// 指定ファイルが既に開かれていたとき、注意喚起
% 	//WarningFileOpen(hWnd);
	
	
% 	return true;
% }

% ///////////////////////////////////////////////
% 	// 指定ファイルが既に開かれていたとき、注意喚起 
% 	///////////////////////////////////////////////
% bool WarningFileOpen(HWND hWnd) {

% 	HANDLE hFile = NULL;
% 	bool Succeeded = false;
% 	int MsgResult;

% 	// ファイルを読み取り専用でオープン
% 	hFile = FileOpenReadOnly(FileName, hFile);

% 	// ファイルが閉じられるまで無限ループ
% 	while (!Succeeded) {
% 		if (hFile != INVALID_HANDLE_VALUE || hFile != (HANDLE)0xffffffff) {
% 			// ファイルが開かれていない場合
% 			CloseHandle(hFile);
% 			Succeeded = true;
% 		}
% 		else {
% 			// 指定ファイルが既に開かれていた場合
% 			MsgResult = MessageBox(
% 				hWnd,
% 				_T("指定されたファイルは既に開かれています。\r\nファイルを閉じてからOKボタンを押してください。"),
% 				_T("ファイルが使用中です"),
% 				MB_OK | MB_ICONWARNING);
% 			if (MsgResult == IDOK) {
% 				// OKボタンが押された場合
% 				CloseHandle(hFile);
% 				hFile = FileOpenReadOnly(FileName, hFile);
% 			}
% 		}
% 	}

% 	return true;
% }

% ///////////////////////////////////////
% // ファイルを読み取り専用でオープン
% //////////////////////////////////////
% HANDLE FileOpenReadOnly(LPCSTR FileName, HANDLE hFile) {

% 	hFile = CreateFile(
% 		FileName,
% 		GENERIC_READ,
% 		0,
% 		NULL,
% 		OPEN_EXISTING,
% 		FILE_ATTRIBUTE_NORMAL,
% 		NULL);

% 	return hFile;
% }
% \end{lstlisting}

% \begin{lstlisting}[caption=UserInfoWindow.cpp]
%   ///////////////////////////////////////////////
% ///UserInfoWindow.cpp: ユーザー情報入力用関数の定義
% //////////////////////////////////////////////

% #include<windows.h>
% #include<tchar.h>
% #include <atlbase.h>
% #include<atlimage.h>
% #include<string>
% #include<io.h>
% #include<CommCtrl.h>
% //#include"torch/torch.h"
% //////////////////////
% // 自作ヘッダファイル
% /////////////////////
% #include "window.h"
% #include "main.h"
% #include"file.h"
% #include"resource.h"
% #include"UserInfoWindow.h"

% ////////////////////////////////////////
% // GDI+
% ////////////////////////////////////////
% #pragma	comment(lib,"Gdiplus.lib")
% #include <ole2.h>
% #include <gdiplus.h>

% #pragma comment(lib, "comctl32.lib")

% ///////////
% // 定数
% ///////////
% #define STRLEN 256
% #define MAX_TOUCH_POINTS 3000          // タッチポイントの記憶上限
% #define MAX_PATH 260
% #define black_pen RGB(0, 0, 0)
% #define white_pen RGB(255, 255, 255)
% #define red_pen RGB(255, 0, 0)
% #define blue_pen RGB(0, 0, 255)
% #define yellow_pen RGB(255, 255, 0)
% #define purple_pen RGB(128, 0, 128)

% #define Black 1
% #define White 2
% #define Red 3
% #define Blue 4
% #define Yellow 5
% #define Purple 6

% ///////////////////////
% // 消しゴムの大きさ
% ///////////////////////
% #define ESmall 11
% #define EMidium 12
% #define EBig 13

% // コントロールのハンドル
% HWND hButtonNext, hStaticName, hStaticOld, hStaticS, hRadioMen, hRadioLady, hStaticComment1, hStaticCombo, hStaticUserInfo, hNameErase, hOldErase;

% extern const HBRUSH BackGround_clear;
% extern std::string fileNameCapture;

% // ツールバーの背景色
% static const HBRUSH hToolbarBackGroundBrush = CreateSolidBrush(RGB(0, 255, 0));

% // ペン
% bool Erase = true;
% UINT PenColor=Black;

% // グローバル変数
% LPTSTR strTextName;
% LPTSTR strTextOld;
% LPCSTR strMenLady;

% // フォント
% HFONT hFontUserInfoWindow1, hFontUserInfoWindowRadio, hFontBig, hTopComment;

% // WM_PAINT
% HDC hMemDC;
% HGDIOBJ hOld;

% // WM_TOUCH
% POINT g_ptPrevious[MAX_TOUCH_POINTS];
% int idLookup[MAX_TOUCH_POINTS];
% bool g_wasinside[MAX_TOUCH_POINTS];

% // WM_COMMAND
% bool clickedRadio = false;

% // RECT構造体変数の定義
% RECT RectTouchTop = { 30, 0, Winsize.right - 30, 85 };
% RECT RectTouchOld = {180, 350, Winsize.right - 70,  500};
% RECT RectTouchOld_1 = {150, 350, 150 + 220, 350 + 220};
% RECT RectTouchOld_2 = { 150 + 220 + 50, 350, 150 + 440 + 50, 350 + 220};
% RECT RectTouchOld_3 = { RectTouchOld_2.right + 50, RectTouchOld_2.top, RectTouchOld_3.left + 220, RectTouchOld_3.top + 220 };
% RECT RectTouchName = { 150, 105, RectTouchOld_3.right,  310 };
% RECT RectTouchS = { 180, 540, 440, 600};
% RECT rcName, rcOld100, rcOld10, rcOld1;

% ///////////////////////////////////
% // 最初に表示されるウィンドウの作成
% ///////////////////////////////////
% HWND CreateNewWindow(HWND hWnd, HINSTANCE hThisInst, const int nWidth, const int nHeight, int nWinMode) {

% 	WNDCLASSEX	wcl2{};
% 	HWND htb{};

% 	//ウィンドウクラスの定義
% 	wcl2.cbSize = sizeof(WNDCLASSEX);				//WNDCLASSEX構造体のサイズ
% 	wcl2.style = 0;									//ウィンドウクラススタイル
% 	wcl2.lpfnWndProc = WndProc2;					//ウィンドウ関数
% 	wcl2.cbClsExtra = 0;							//ウィンドウクラスのエキストラ
% 	wcl2.cbWndExtra = 0;							//ウィンドウインスタンスのエキストラ
% 	wcl2.hInstance = hThisInst;						//このプログラムのインスタンスへのハンドル
% 	wcl2.hIcon = LoadIcon(NULL, IDI_APPLICATION);	//アイコンへのハンドル
% 	wcl2.hCursor = LoadCursor(NULL, IDC_ARROW);		//カーソルへのハンドル
% 	wcl2.hbrBackground = BackGround_clear;           //(HBRUSH)GetStockObject(NULL_BRUSH); //背景ブラシへのハンドル
% 	wcl2.lpszMenuName = MAKEINTRESOURCE(IDR_MENU2);;	//メニュー
% 	wcl2.lpszClassName = _T("NewWindowClass");					//ウィンドウクラス名
% 	wcl2.hIconSm = LoadIcon(NULL, IDI_WINLOGO);		//スモールアイコンへのハンドル

% 	if (!RegisterClassEx(&wcl2)) {
% 		return FALSE;
% 	}

% 	hWnd = CreateWindowEx(
% 		0,                                                                                            
% 		_T("NewWindowClass"),                                                                          //ウィンドウクラス名
% 		_T("ユーザー情報の入力"),				                                                         //ウィンドウ名
% 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,	 //ウィンドウスタイル
% 		CW_USEDEFAULT, CW_USEDEFAULT,			 
% 		nWidth,	 nHeight,			    
% 		HWND_DESKTOP,	//親ウィンドウへのハンドル
% 		NULL,					//メニューへのハンドル
% 		hThisInst,				//このプログラムのインスタンスへのハンドル
% 		NULL					    //追加引数
% 	);

% 	if (!hWnd) {
% 		return FALSE;
% 	}
% 	// ウィンドウの表示
% 	ShowWindow(hWnd, nWinMode);
% 	UpdateWindow(hWnd);



% 	if (!RegisterTouchWindow(hWnd, 0)) {
% 		MessageBox(hWnd, _T("このデバイスにはタッチ機能がありません。"), _T("Error"), MB_OK);
% 		return FALSE;
% 	}

% 	// POINT構造体の配列の初期化（WM_TOUCHで使用）
% 	for (size_t i = 0; i < MAX_TOUCH_POINTS; i++) {
% 		g_ptPrevious[i].x = -1;
% 		g_ptPrevious[i].y = -1;
% 		idLookup[i] = -1;
% 	}

% 	// アプリのアイコンを変更
% 	HICON hIcon;
% 	hIcon = (HICON)LoadImage(hThisInst, MAKEINTRESOURCE(IDI_ICON1), IMAGE_ICON, 48, 48, 0);
% 	SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);

% 	return hWnd;
% }

% //////////////////////////////
% // ツールバー作成用関数
% //////////////////////////////
% HWND CreateToolbarFunc(HWND hWnd, LPARAM lParam) {

% 	INITCOMMONCONTROLSEX icc{};
% 	icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
% 	icc.dwICC = ICC_BAR_CLASSES;
% 	InitCommonControlsEx(&icc);
	
% 	HIMAGELIST g_hImageList = NULL;

% 	// Declare and initialize local constants
% 	const int numButtons = 2;
% 	const int bitmapSize = 26;


% 	// Create the toolbar
% 	HWND hToolbar = CreateWindowEx(
% 		0,
% 		TOOLBARCLASSNAME,
% 		NULL,
% 		WS_CHILD | WS_VISIBLE | TBSTYLE_LIST,
% 		0, 0, 0, 0,
% 		hWnd,
% 		(HMENU)IDT_TOOLBAR,
% 		((LPCREATESTRUCT)(lParam))->hInstance,
% 		NULL
% 	);

% 	if (hToolbar == NULL) {
% 		return NULL;
% 	}

% 	// ツールバーの初期化
% 	SendMessage(hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
% 	SendMessage(hToolbar, TB_SETBITMAPSIZE, 0, MAKELPARAM(bitmapSize, bitmapSize));

% 	// ビットマップの登録
% 	TBADDBITMAP tb{};
% 	tb.hInst = NULL;
% 	tb.nID = (UINT_PTR)LoadBitmap(((LPCREATESTRUCT)(lParam))->hInstance, MAKEINTRESOURCE(IDB_BITMAP10));
% 	SendMessage(hToolbar, TB_ADDBITMAP, (WPARAM)numButtons, (LPARAM)&tb);

% 	//　ボタンの定義と登録
% 	TBBUTTON tbb[numButtons] = {
% 		{0, IDT_TOOLBAR_PEN, TBSTATE_ENABLED,
% 		BTNS_BUTTON | BTNS_CHECKGROUP, 
% 		{0}, 0, (INT_PTR)_T("ペン")},
% 		{1, IDT_TOOLBAR_ERASER, TBSTATE_ENABLED,
% 		BTNS_BUTTON | BTNS_CHECKGROUP, 
% 		{0}, 0, (INT_PTR)_T("消しゴム")}
% 	};
% 	SendMessage(hToolbar, TB_ADDBUTTONS, (WPARAM)numButtons, (LPARAM)&tbb);


% 	return hToolbar;
% }

% //////////////////////////////
% // ウィンドウプロージャの定義
% //////////////////////////////
% LRESULT CALLBACK WndProc2(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam){
% 	switch (uMsg) {
		
% 	case WM_DESTROY:
% 		// 後始末
% 		DeleteObject(hFontUserInfoWindow1);
% 		DeleteObject(hFontUserInfoWindowRadio);
% 		DeleteObject(hToolbarBackGroundBrush);
% 		DeleteObject(hFontBig);
% 		DeleteObject(hTopComment);

% 		SelectObject(hMemDC, hOld);
% 		DeleteDC(hMemDC);

% 		PostQuitMessage(0);
% 		return 0;

% 	case WM_CREATE:
% 		OnCreate(hWnd, wParam, lParam);

% 		break;
	
% 	case WM_COMMAND:
% 		OnCommand(hWnd, wParam, lParam);
% 		break;

% 	case WM_TOUCH:
% 		OnTouch(hWnd, wParam, lParam);
% 		break;

% 	case WM_CTLCOLORSTATIC:
% 		return (OnCtlColorStatic(wParam, lParam));

% 	case WM_ERASEBKGND:
% 		// 何も処理しない(画面のちらつき防止）
% 		return 1;
% 		break;

% 	case WM_PAINT:
% 	{
% 		PAINTSTRUCT ps;
% 		HDC hdc = BeginPaint(hWnd, &ps);

% 		// メモリDCからDCにコピー
% 		BitBlt(ps.hdc,
% 			ps.rcPaint.left, ps.rcPaint.top,
% 			ps.rcPaint.right - ps.rcPaint.left, ps.rcPaint.bottom - ps.rcPaint.top,
% 			hMemDC,
% 			ps.rcPaint.left, ps.rcPaint.top,
% 			SRCCOPY);

% 		EndPaint(hWnd, &ps);
% 		return 0;
% 	}

% 	case WM_CLOSE:
% 		if (MessageBox(hWnd, _T("終了しますか？"), _T("終了確認"), MB_YESNO | MB_ICONQUESTION) == IDYES) {
% 			DestroyWindow(hWnd);
% 		}
% 		break;

% 	default:
% 		return (DefWindowProc(hWnd, uMsg, wParam, lParam));
% 	}
% 	return(0);
% }

% //////////////////////////
% // WM_TOUCH内の処理
% //////////////////////////
% bool OnTouch(HWND hWnd, WPARAM wParam, LPARAM lParam) {

% 	UINT cInputs = LOWORD(wParam);
% 	PTOUCHINPUT pInputs = new TOUCHINPUT[cInputs];
% 	HPEN hNewPen{};
% 	int index;

% 	// ペンの色の選定
% 	hNewPen = SelectPenColor(hNewPen);

% 	if (pInputs){
% 		if (GetTouchInputInfo((HTOUCHINPUT)lParam, cInputs, pInputs, sizeof(TOUCHINPUT))){
% 			HDC hdc = GetDC(hWnd);
% 			HPEN hOldPen = (HPEN)SelectObject(hdc, hNewPen);
% 			if (hdc) {
% 				for (UINT i = 0; i < cInputs; i++) {
% 					TOUCHINPUT ti = pInputs[i];
% 					POINT pt = {0, 0};
% 					// タッチポイントを取得
% 					pt.x = TOUCH_COORD_TO_PIXEL(ti.x);
% 					pt.y = TOUCH_COORD_TO_PIXEL(ti.y);
% 					// 絶対座標に変換
% 					ScreenToClient(hWnd, &pt);
% 					index = GetContactIndex(ti.dwID);
% 					// タッチポイントがタッチパネル内にあるとき
% 					if (PtInRect(&RectTouchName, pt) || PtInRect(&RectTouchOld_1, pt) || PtInRect(&RectTouchOld_2, pt) || PtInRect(&RectTouchOld_3, pt)) {
% 						if (ti.dwFlags & TOUCHEVENTF_DOWN) {
% 							if (index < MAX_TOUCH_POINTS && index >= 0) {
% 								// タッチポイントの座標を記憶する
% 								g_ptPrevious[index] = pt;
% 								// タッチパネル内であることを記憶
% 								g_wasinside[index] = true;
% 							}
% 						}
% 						else if (ti.dwFlags & TOUCHEVENTF_MOVE) {
% 							if (index < MAX_TOUCH_POINTS && index >= 0) {	
% 								if (g_wasinside[index]) { // 前回のタッチポイントがタッチパネル内であったかのチェック
% 									POINT ptCurrent = g_ptPrevious[index];
% 									// 記憶したタッチポイントから次のタッチポイントまで線を引く
% 									MoveToEx(hdc, ptCurrent.x, ptCurrent.y, NULL);
% 									LineTo(hdc, pt.x, pt.y);
% 								}
% 									g_ptPrevious[index] = pt;
% 									g_wasinside[index] = true;
% 							}
% 						}
% 					}
% 					// タッチポイントがタッチパネル外にあるとき
% 					else {
% 						if (index < MAX_TOUCH_POINTS && index >= 0) {
% 							g_wasinside[index] = false;
% 						}
% 						break;
% 					}
% 				}
% 				// ペンの削除
% 				SelectObject(hdc, hOldPen);
% 				DeleteObject(hNewPen);
% 				// デバイスコンテキストの解放
% 				ReleaseDC(hWnd, hdc);
% 			}
% 		}
% 		delete[] pInputs;
% 		CloseTouchInputHandle((HTOUCHINPUT)lParam);
% 	}
% 	return true;
% }

% //////////////////////////////////////////////////////////////////////
% // タッチイベント情報用配列のインデックス番号への変換と取得
% /////////////////////////////////////////////////////////////////////
% int GetContactIndex(int dwID) {
% 	for (int i = 0; i < MAX_TOUCH_POINTS; i++) {
% 		if (idLookup[i] == -1) {
% 			idLookup[i] = dwID;
% 			return i;
% 		}
% 		else {
% 			if (idLookup[i] == dwID) {
% 				return i;
% 			}
% 		}
% 	}
% 	// Out of contacts
% 	return -1;
% }
% ////////////////////
% // ペンの色の選定
% ////////////////////
% HPEN SelectPenColor(HPEN hNewPen) {
% 	// ペンの選定
% 	switch (PenColor) {
% 	case Black:
% 		hNewPen = CreatePen(PS_SOLID, 5, black_pen);
% 		break;
% 	case Red:
% 		hNewPen = CreatePen(PS_SOLID, 5, red_pen);
% 		break;
% 	case Blue:
% 		hNewPen = CreatePen(PS_SOLID, 5, blue_pen);
% 		break;
% 	case Yellow:
% 		hNewPen = CreatePen(PS_SOLID, 5, yellow_pen);
% 		break;
% 	case Purple:
% 		hNewPen = CreatePen(PS_SOLID, 5, purple_pen);
% 		break;
% 	case ESmall:
% 		hNewPen = CreatePen(PS_SOLID, 4, white_pen);
% 		break;
% 	case EMidium:
% 		hNewPen = CreatePen(PS_SOLID, 12, white_pen);
% 		break;
% 	case EBig:
% 		hNewPen = CreatePen(PS_SOLID, 20, white_pen);
% 		break;
% 	default:
% 		break;
% 	}
% 	return hNewPen;
% }

% ////////////////////
% //WM_CREATE内の処理
% /////////////////////
% bool OnCreate(HWND hWnd, WPARAM wParam, LPARAM lParam){
% 	// ウィンドウをデスクトップ上の中央に移動
% 	DesktopCenterWindow(hWnd);
% 	// コントロールの作成
% 	CreateControl(hWnd, wParam, lParam);
% 	//[名前を付けて保存]ダイアログボックスを呼び出す
% 	SelectFile(hWnd);
% 	// メモリデバイスコンテキストの取得
% 	GetUserInfoWindowMemDC(hWnd);
% 	// メモリデバイスコンテキストへの描画
% 	PaintToMemDC(hWnd);
% 	// フォントの変更
% 	OnFont();
% 	// ツールバーの作成
% 	//CreateToolbarFunc(hWnd, lParam);

% 	return true;
% }

% ////////////////////
% // ウィンドウの座標をRECT構造体で取得
% // ////////////////////
% RECT GetScreenRectFunc(HWND hWnd, RECT rc) {

% 	POINT topLeft = { rc.left, rc.top };
% 	POINT bottomRight = { rc.right, rc.bottom };
% 	ClientToScreen(hWnd, &topLeft);
% 	ClientToScreen(hWnd, &bottomRight);
% 	rc.left = topLeft.x;
% 	rc.top = topLeft.y;
% 	rc.right = bottomRight.x;
% 	rc.bottom = bottomRight.y;

% 	return rc;
% }

% ////////////////////
% //WM_COMMAND内の処理
% /////////////////////
% bool OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam) {

% 	switch (LOWORD(wParam)) {
% 	case ID2_PUSHBUTTON1:
% 		if (HIWORD(wParam) == BN_CLICKED) {
% 			// 指定したウィンドウ領域のキャプチャ
% 			GetWindowImage(hWnd);
			
% 			// 2つ目のウィンドウを呼び出す処理
% 			ShowWindow(hWnd, SW_HIDE);
% 			CreateParentWindow(hWnd, hInst, SW_SHOW, _T("Group1"), 
% 				Winsize.right - Winsize.left, Winsize.bottom - Winsize.top);
% 			// 開始ボタンの有効化
% 			EnableWindow(hReserch, TRUE);
% 		}
% 		break;
% 	case ID2_RADIOMEN:
% 		if (BST_CHECKED == SendMessage(GetDlgItem(hWnd, ID2_RADIOMEN), BM_GETCHECK, 0, 0)) {
% 			strMenLady = _T(",,男,");
% 			if (!clickedRadio) {
% 				EnableWindow(GetDlgItem(hWnd, ID2_PUSHBUTTON1), TRUE);
% 				clickedRadio = true;
% 			}
% 		}
% 		break;
% 	case ID2_RADIOLADY:
% 		if (BST_CHECKED == SendMessage(GetDlgItem(hWnd, ID2_RADIOLADY), BM_GETCHECK, 0, 0)) {
% 			strMenLady = _T(",,女,");
% 			if (!clickedRadio) {
% 				EnableWindow(GetDlgItem(hWnd, ID2_PUSHBUTTON1), TRUE);
% 				clickedRadio = true;
% 			}
% 		}
% 		break;

% 	case ID_LATEINI:
% 		LateIniFunc(hWnd, wParam);
% 		break;

% 	case ID2_PUSHBUTTONERASE_1:
% 		if (HIWORD(wParam) == BN_CLICKED) {
% 			// 名前の取り消しボタン
% 			EraseFunc(hWnd, RectTouchName);
% 		}
% 		break;

% 	case ID2_PUSHBUTTONERASE_2:
% 		if (HIWORD(wParam) == BN_CLICKED) {
% 			// 年齢の取り消しボタン
% 			//EraseFunc(hWnd, RectTouchOld_1);
% 			EraseFunc(hWnd, RectTouchOld_2);
% 			EraseFunc(hWnd, RectTouchOld_3);
% 		}
% 		break;
    
% 	////////////////
% 	// ツールバー
% 	////////////////
% 	case IDT_TOOLBAR_PEN:
% 		MessageBox(hWnd, _T("ツールバー1がクリックされました。"), _T("ボタン1"), MB_OK);
% 		break;

% 	case IDT_TOOLBAR_ERASER:
% 		MessageBox(hWnd, _T("ツールバー2がクリックされました。"), _T("ボタン2"), MB_OK);
% 		break;

% 	////////////////
% 	// メニューバー
% 	// /////////////
% 	// 消しゴム
% 	case ID_ERASE_SMALL:
% 		GetClicked(wParam, ESmall);
% 		break;
% 	case ID_ERASE_MIDIUM:
% 		GetClicked(wParam, EMidium);
% 		break;
% 	case ID_ERASE_BIG:
% 		GetClicked(wParam, EBig);
% 		break;
% 		// ペン
% 	case ID_PEN_BLACK:
% 		GetClicked(wParam, Black);
% 		break;
% 	case ID_PEN_RED:
% 		GetClicked(wParam, Red);
% 		break;
% 	case ID_PEN_BLUE:
% 		GetClicked(wParam, Blue);
% 		break;
% 	case ID_PEN_YELLOW:
% 		GetClicked(wParam, Yellow);
% 		break;
% 	case ID_PEN_PURPLE:
% 		GetClicked(wParam, Purple);
% 		break;

% 	default:
% 		break;
% 	}

% 	return true;
% }

% ////////////////////////
% // クリックの検出と色の保存
% ///////////////////////
% UINT GetClicked(WPARAM wParam, UINT Color) {
% 	if (HIWORD(wParam) == BN_CLICKED) {
% 		PenColor = Color;
% 	}
% 	return PenColor;
% }

% /////////////////////////
% // ビットマップの作成
% // //////////////////////
% bool CreateBitmap(HDC hdcWindow, int width, int height) {
% 	HDC hdcMemDC = CreateCompatibleDC(hdcWindow);
% 	HBITMAP hBitmap = CreateCompatibleBitmap(hdcWindow, width, height);
% 	HGDIOBJ hdcMemDC_old = SelectObject(hdcMemDC, hBitmap);
% 	return true;
% }

% /////////////////////////
% // ウィンドウをキャプチャ
% /////////////////////////
% bool GetWindowImage(HWND hWnd) {
	 
% 	// キャプチャ対象のウィンドウのDCを取得
% 	HDC hdcWindow = GetDC(hWnd);

% 	// キャプチャ対象のウィンドウのクライアント領域の大きさを取得
% 	RECT rcClient;
% 	if (!GetClientRect(hWnd, &rcClient)) {
% 		return false;
% 	}
% 	// クライアント領域のサイズを計算
% 	int width = rcClient.right - rcClient.left;
% 	int height = rcClient.bottom - rcClient.top;
% 	// 年齢の100の桁
% 	int width_1 = RectTouchOld_1.right - RectTouchOld_1.left;
% 	int height_1 = RectTouchOld_1.bottom - RectTouchOld_1.top;
% 	// 年齢の10の桁
% 	int width_2 = RectTouchOld_2.right - RectTouchOld_2.left;
% 	int height_2 = RectTouchOld_2.bottom - RectTouchOld_2.top;
% 	// 年齢の1の桁
% 	int width_3 = RectTouchOld_3.right - RectTouchOld_3.left;
% 	int height_3 = RectTouchOld_3.bottom - RectTouchOld_3.top;

% 	// 指定された大きさのビットマップを作成
% 	HDC hdcMemDC = CreateCompatibleDC(hdcWindow);
% 	HDC hdcMemDC_1 = CreateCompatibleDC(hdcWindow); 
% 	HDC hdcMemDC_2 = CreateCompatibleDC(hdcWindow);
% 	HDC hdcMemDC_3 = CreateCompatibleDC(hdcWindow);
% 	HBITMAP hBitmap = CreateCompatibleBitmap(hdcWindow, width, height);
% 	HBITMAP hBitmap_1 = CreateCompatibleBitmap(hdcWindow, width_1, height_1);
% 	HBITMAP hBitmap_2 = CreateCompatibleBitmap(hdcWindow, width_1, height_1);
% 	HBITMAP hBitmap_3 = CreateCompatibleBitmap(hdcWindow, width_1, height_1);
% 	HGDIOBJ hdcMemDC_old = SelectObject(hdcMemDC, hBitmap);
% 	HGDIOBJ hdcMemDC_old_1 = SelectObject(hdcMemDC_1, hBitmap_1);
% 	HGDIOBJ hdcMemDC_old_2 = SelectObject(hdcMemDC_2, hBitmap_2);
% 	HGDIOBJ hdcMemDC_old_3 = SelectObject(hdcMemDC_3, hBitmap_3);

% 	// 作成したビットマップにキャプチャ内容を描画
% 	// ウィンドウ全体
% 	BitBlt(hdcMemDC,
% 		0, 0, width, height,  // コピー先
% 		hdcWindow,
% 		0, 0,                       // コピー元のビットマップの左上隅の座標
% 		SRCCOPY);

% 	// 年齢100桁
% 	BitBlt(hdcMemDC_1, 
% 		0, 0, width_1, height_1,                            
% 		hdcWindow, 
% 		RectTouchOld_1.left, RectTouchOld_1.top, 
% 		SRCCOPY);
% 	// 年齢10桁
% 	BitBlt(hdcMemDC_2,
% 		0, 0, width_2, height_2,                             
% 		hdcWindow,
% 		RectTouchOld_2.left, RectTouchOld_2.top, 
% 		SRCCOPY);
% 	// 年齢1桁
% 	BitBlt(hdcMemDC_3,
% 		0, 0, width_3, height_3,                            
% 		hdcWindow,
% 		RectTouchOld_3.left, RectTouchOld_3.top, 
% 		SRCCOPY);

% 	// CImageクラスのインスタンスを作成
% 	CImage image, image1, image2, image3;
% 	// 作成したビットマップをCImageクラスにロード
% 	image.Attach(hBitmap);
% 	image1.Attach(hBitmap_1);
% 	image2.Attach(hBitmap_2);
% 	image3.Attach(hBitmap_3);

% 	// キャプチャした画像の保存先フォルダーの作成
% 	const char* folderName = _T("Capture");
% 	if (!CreateCaptureFolder(hWnd, folderName)) {  // folderNameが存在しない場合
% 		// フォルダーの作成
% 		CreateDirectory(folderName, NULL);
% 		// サブフォルダーの作成
% 		const char* subdirectories[] = { _T("One_digits"), _T("Ten_digits"), _T("Handred_digits"), _T("Window_capture") };
% 		createSubdirectories(folderName, subdirectories, sizeof(subdirectories) / sizeof(subdirectories[0]));
% 	}
	
% 	// ファイル名の定義
% 	std::string filename_100, filename_10, filename_1;
% 	fileNameCapture = _T("./Capture/Window_capture/capture_0.jpeg");
% 	filename_1 = _T("./Capture/One_digits/One_digits_0.jpeg");
% 	filename_10 = _T("./Capture/Ten_digits/Ten_digits_0.jpeg");
% 	filename_100 = _T("./Capture/Handred_digits/Handred_digits_0.jpeg");

% 	for (size_t i = 1; i < 1000; i++){
% 		if (_access_s(fileNameCapture.c_str(), 0 == ENOENT)){
% 			// FileName does not exist
% 			break;
% 		}
% 		fileNameCapture = _T("./Capture/Window_Capture/capture_") 
% 			+ std::to_string(i) + _T(".jpeg");
% 		filename_1 = _T("./Capture/One_digits/One_digits_") +
% 			std::to_string(i) + _T(".jpeg");
% 		filename_10 = _T("./Capture/Ten_digits/Ten_digits_") +
% 			std::to_string(i) + _T(".jpeg");
% 		filename_100 = _T("./Capture/Handred_digits/Handred_digits_") +
% 			std::to_string(i) + _T(".jpeg");
% 	}

% 	// 画像を保存
% 	HRESULT a, b, c, d;
% 	a = image.Save(fileNameCapture.c_str(), Gdiplus::ImageFormatJPEG);
% 	b = image3.Save(filename_1.c_str(), Gdiplus::ImageFormatJPEG);
% 	c = image2.Save(filename_10.c_str(), Gdiplus::ImageFormatJPEG);
% 	d = image1.Save(filename_100.c_str(), Gdiplus::ImageFormatJPEG);
% 	if (a != S_OK || b != S_OK || c != S_OK || d != S_OK) {
% 		MessageBox(hWnd, _T("画像の保存に失敗しました。"), _T("エラー"), MB_ICONWARNING);
% 		return false;
% 	}
% 	// ビットマップのリサイズ（28×28)
% 	//CImage resizedImage = ResizeImage(image, 28, 28);
% 	// リサイズされたビットマップをtorch::Tensorに変換
% 	//torch::Tensor reseizedTensor = CImageToTensor(resizedImage);
% 	// 
% 	// CImageからhBitmapをデタッチ
% 	image.Detach();
% 	image1.Detach();
% 	image2.Detach();
% 	image3.Detach();
% 	// リソースを解放
% 	ReleaseDC(hWnd, hdcWindow);
% 	// メモリDC削除前にメモリDCを変更前のグラフィックスオブジェクトと関連付ける
% 	SelectObject(hdcMemDC, hdcMemDC_old);
% 	SelectObject(hdcMemDC_1, hdcMemDC_old_1);
% 	SelectObject(hdcMemDC_2, hdcMemDC_old_1);
% 	SelectObject(hdcMemDC_3, hdcMemDC_old_1);

% 	// 先にビットマップを削除する
% 	DeleteObject(hBitmap);
% 	DeleteObject(hBitmap_1);
% 	DeleteObject(hBitmap_2);
% 	DeleteObject(hBitmap_3);
% 	// メモリDCの削除
% 	DeleteDC(hdcMemDC);
% 	DeleteDC(hdcMemDC_1);
% 	DeleteDC(hdcMemDC_2);
% 	DeleteDC(hdcMemDC_3);

% 	return true;
% }

% ////////////////////
% // フォルダの作成
% // /////////////////
% bool CreateCaptureFolder(HWND hWnd, const char* folderName) {
% 	// カレントディレクトリのハンドルを取得
% 	HANDLE hFind;
% 	WIN32_FIND_DATAA findData;
% 	char searchPath[MAX_PATH];

% 	// カレントディレクトリを取得
% 	GetCurrentDirectory(MAX_PATH, searchPath);
% 	// 探索パターンを追加
% 	strcat_s(searchPath, MAX_PATH, "\\*");

% 	bool folderExists = false;
% 	// ディレクトリの探索を開始
% 	hFind = FindFirstFile(searchPath, &findData);
	
% 	if (hFind != INVALID_HANDLE_VALUE) {
% 		do {
% 			if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) { // ディレクトリかどうかを確認
% 				if (strcmp(findData.cFileName, folderName) == 0) { // ディレクトリ名が一致するかどうか確認
% 					folderExists = true;
% 					break;
% 				}
% 			}
% 		} while (FindNextFile(hFind, &findData));
% 		{FindClose(hFind); }// ハンドルを閉じる
% 	}
% 	return folderExists;
% }

% ////////////////////////////
% // サブディレクトリの作成
% ////////////////////////////
% bool createSubdirectories(const char* parentPath, const char* subdirectories[], UINT numSubdirectories) {
% 	char subdirectoryPath[MAX_PATH];

% 	for (UINT i = 0; i < numSubdirectories; i++) {
% 		snprintf(subdirectoryPath, sizeof(subdirectoryPath), _T("%s\\%s"), parentPath, subdirectories[i]);
% 		CreateDirectory(subdirectoryPath, NULL);
% 	}
% 	return true;
% }


% ////////////////////
% //コントロールの作成
% /////////////////////
% bool CreateControl(HWND hWnd, WPARAM wParam, LPARAM lParam) {

% 	// Push Button Style
% 	hNameErase = CreateWindowEx(
% 		WS_EX_WINDOWEDGE,
% 		_T("BUTTON"),
% 		_T("取り消し"),
% 		WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
% 		RectTouchName.right + (Winsize.right - RectTouchName.right) / 2 - 75, 
% 		RectTouchName.top + (RectTouchName.bottom - RectTouchName.top) / 2 - 50, 
% 		150, 100,
% 		hWnd, (HMENU)ID2_PUSHBUTTONERASE_1, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	hOldErase = CreateWindowEx(
% 		WS_EX_WINDOWEDGE,
% 		_T("BUTTON"),
% 		_T("取り消し"),
% 		WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
% 		RectTouchOld_3.right + (Winsize.right - RectTouchOld_3.right) / 2 - 75, 
% 		RectTouchOld_3.top + (RectTouchOld_3.bottom - RectTouchOld_3.top)  /  2  - 50, 
% 		150, 100,
% 		hWnd, (HMENU)ID2_PUSHBUTTONERASE_2, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	hButtonNext = CreateWindowEx(
% 		WS_EX_WINDOWEDGE,
% 		_T("BUTTON"),
% 		_T("次の画面に進む＞"),
% 		WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON | WS_DISABLED,
% 		Winsize.right / 2 - 200, Winsize.bottom - 72, 400, 55,
% 		hWnd, (HMENU)ID2_PUSHBUTTON1, ((LPCREATESTRUCT)(lParam))->hInstance, NULL);

% 	// Static Style

% 	/*hStaticUserInfo = CreateWindow(
% 		_T("STATIC"),
% 		_T("ユーザー情報の入力"),
% 		WS_CHILD | WS_VISIBLE | SS_LEFT,
% 		RectTouchName.left, RectTouchName.top - 145, 800, 50,
% 		hWnd, (HMENU)ID2_STATICUSERINFO,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);*/

% 	hStaticCombo = CreateWindow(
% 		_T("STATIC"),
% 		_T("遅延時間の設定:"),
% 		WS_CHILD | WS_VISIBLE | SS_LEFT,
% 		Winsize.right - 300 - 260, RectTouchS.top + 65, 260, 70,
% 		hWnd, (HMENU)ID2_STATICCOMBO,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	hStaticComment1 = CreateWindow(
% 		_T("STATIC"),
% 		_T("名前・年齢・性別を回答してください。"),
% 		WS_CHILD | WS_VISIBLE | SS_LEFT,
% 		RectTouchName.left, RectTouchName.top -80 + 20, 800 ,  50 - 10,
% 		hWnd, (HMENU)ID2_STATICCOMMENT1,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	hStaticName = CreateWindow(
% 		_T("STATIC"),
% 		_T("名前:"),
% 		WS_CHILD | WS_VISIBLE | SS_LEFT,
% 		30, RectTouchName.top + 65, 100, 60,
% 		hWnd, (HMENU)ID2_STATICNAME,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	hStaticOld = CreateWindow(
% 		_T("STATIC"),
% 		_T("年齢:"),
% 		WS_CHILD | WS_VISIBLE | SS_LEFT,
% 		30, RectTouchOld.top + 65, 100, 60,
% 		hWnd, (HMENU)ID2_STATICOLD,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	hStaticS = CreateWindow(
% 		_T("STATIC"),
% 		_T("性別:"),
% 		WS_CHILD | WS_VISIBLE | SS_LEFT,
% 		30, RectTouchS.top + 65, 100, 60,
% 		hWnd, (HMENU)ID2_STATICS,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	// Radio Button Style
% 	hRadioMen = CreateWindow(
% 		_T("BUTTON"),
% 		_T("男性"),
% 		WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON | SS_CENTER,
% 		RectTouchS.left, RectTouchS.top + 55, 100, 60,
% 		hWnd, (HMENU)ID2_RADIOMEN,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	hRadioLady = CreateWindow(
% 		_T("BUTTON"),
% 		_T("女性"),
% 		WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON | SS_CENTER,
% 		RectTouchS.left+ 150 , RectTouchS.top + 55, 100, 60,
% 		hWnd, (HMENU)ID2_RADIOLADY,
% 		((LPCREATESTRUCT)(lParam))->hInstance, NULL
% 	);

% 	ComboboxFunc(hWnd, lParam);           // 遅延時間設定用

% 	// コンボボックスの先頭項目の文字列の長さを取得
% 	int intTxtLen = SendMessage(GetDlgItem(hWnd, (int)ID_LATEINI), CB_GETLBTEXTLEN, 0, 0);
% 	char* pszBuf = new char[intTxtLen + 1];
% 	// コンボボックスの先頭項目の文字列を取得
% 	if (SendMessage(GetDlgItem(hWnd, (int)ID_LATEINI), CB_GETLBTEXT, 0, (LPARAM)pszBuf) != CB_ERR) {
% 		char Path[MAX_PATH + 1];
% 		char settingpath[MAX_PATH + 1]{};
% 		settingpath[0] = '\0';
% 		if (0 != GetModuleFileName(NULL, Path, MAX_PATH)) {
% 			char drive[MAX_PATH + 1], dir[MAX_PATH + 1], fname[MAX_PATH + 1], ext[MAX_PATH + 1];
% 			_splitpath_s(Path, drive, sizeof(drive), dir, sizeof(dir),
% 				fname, sizeof(fname), ext, sizeof(ext));
% 			_stprintf_s(settingpath, MAX_PATH + 1, _T("%s%ssetting.ini"), drive, dir);
% 		}
% 		// iniファイルから選択したキーの遅延時間を取得しlatedataに保存
% 		GetPrivateProfileString(pszBuf, _T("data"), _T("error"), latedata, sizeof(latedata), settingpath);
% 	}
% 	delete[] pszBuf;

% 	return true;
% }

% //////////////////////////
% // WM_CTLCOLORSTATIC内の処理
% ///////////////////////////
% long OnCtlColorStatic(WPARAM wParam, LPARAM lParam) {

% 	int i = GetWindowLong((HWND)lParam, GWL_ID);
% 	if (i == 0) {
% 		return -1;
% 	}else {
% 		if ((i == ID2_STATICUSERINFO) || (i == ID2_STATICCOMMENT1)) {
% 			SetBkMode((HDC)wParam, TRANSPARENT);
% 			SetTextColor((HDC)wParam, RGB(30, 144, 255));
% 			return (long)BackGround_clear;
% 		}
% 		else if (i == IDT_TOOLBAR){
% 			SetBkMode((HDC)wParam, TRANSPARENT);
% 			return (long)hToolbarBackGroundBrush;
% 		}else {
% 			SetBkMode((HDC)wParam, TRANSPARENT);
% 			return (long)BackGround_clear;
% 		}
% 	}
% }

% //////////////////////////////////////////////////
% // メモリデバイスコンテキスト描画の事前準備
% //////////////////////////////////////////////////
% bool GetUserInfoWindowMemDC(HWND hWnd) {

% 	HDC hDC;
% 	HBITMAP hBitmap;
	
% 	// デバイスコンテキストの取得
% 	hDC = GetDC(hWnd);
% 	// メモリデバイスコンテキストの取得
% 	hMemDC = CreateCompatibleDC(hDC);
% 	// ビットマップハンドルの取得
% 	hBitmap = CreateCompatibleBitmap(hDC, Winsize.right, Winsize.bottom);
% 	// デバイスコンテキストの解放
% 	ReleaseDC(hWnd, hDC);
% 	// メモリDCにビットマップを割りつけ
% 	hOld = SelectObject(hMemDC, hBitmap);
% 	// ビットマップの削除
% 	DeleteObject(hBitmap);

% 	return true;
% }

% //////////////////////////////////////////
% // メモリデバイスコンテキストへの描画
% //////////////////////////////////////////
% bool PaintToMemDC(HWND hWnd) {
% 	// 背景の塗りつぶし
% 	FillRect(hMemDC, &Winsize, BackGround_clear);
% 	// 名前入力用タッチパネル
% 	FillRect(hMemDC, &RectTouchName, (HBRUSH)CreateSolidBrush(RGB(255, 255, 255))); 
% 	// 年齢入力用タッチパネル
% 	//FillRect(hMemDC, &RectTouchOld, (HBRUSH)CreateSolidBrush(RGB(255, 255, 255)));
% 	// 年齢入力用タッチパネル 100の桁
% 	FillRect(hMemDC, &RectTouchOld_1, (HBRUSH)CreateSolidBrush(RGB(255,255,255)));
% 	// 年齢入力用タッチパネル　10の桁
% 	FillRect(hMemDC, &RectTouchOld_2, (HBRUSH)CreateSolidBrush(RGB(255, 255, 255)));
% 	// 年齢用入力用タッチパネル 100の桁
% 	FillRect(hMemDC, &RectTouchOld_3, (HBRUSH)CreateSolidBrush(RGB(255, 255, 255)));
% 	// ボタンの背景色の描画
% 	FillRect(hMemDC, &FrameBottom, (HBRUSH)CreateSolidBrush(RGB(70, 130, 180)));

% 	// 枠線の描画
% 	//DrawEdge(hMemDC, &RectTouchTop, EDGE_BUMP, BF_BOTTOM);
% 	DrawEdge(hMemDC, &RectTouchName, EDGE_BUMP, BF_RECT);
% 	//DrawEdge(hMemDC, &RectTouchOld, EDGE_BUMP, BF_RECT);
% 	DrawEdge(hMemDC, &RectTouchOld_1, EDGE_BUMP, BF_RECT);
% 	DrawEdge(hMemDC, &RectTouchOld_2, EDGE_BUMP, BF_RECT);
% 	DrawEdge(hMemDC, &RectTouchOld_3, EDGE_BUMP, BF_RECT);
% 	return true;
% }

% bool EraseFunc(HWND hWnd, RECT rc){
% 	HDC hDC = GetDC(hWnd);
% 	FillRect(hDC, &rc, (HBRUSH)CreateSolidBrush(RGB(255, 255, 255)));
% 	DrawEdge(hDC, &rc, EDGE_BUMP, BF_RECT);

% 	return true;
% }
% ////////////////////
% //フォントの変更
% /////////////////////
% bool OnFont() {
% 	// 新しくHFONT型変数を追加する場合は、WM_DESTROYメッセージ内でのDeleteObject(HFONT)を忘れないように。

% 	hFontUserInfoWindow1 = CreateFont(
% 		40, 0, 0, 0,
% 		FW_MEDIUM,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hFontUserInfoWindowRadio = CreateFont(
% 		50, 0, 0, 0,
% 		FW_MEDIUM,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hFontBig = CreateFont(
% 		50, 0, 0, 0,
% 		FW_BOLD,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hTopComment = CreateFont(
% 		40, 0, 0, 0,
% 		FW_BOLD,
% 		false, false, false,
% 		SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
% 		(VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	// To Static
% 	SendMessage(hStaticName, WM_SETFONT, (WPARAM)hFontUserInfoWindow1, MAKELPARAM(false, 0));
% 	SendMessage(hStaticOld, WM_SETFONT, (WPARAM)hFontUserInfoWindow1, MAKELPARAM(false, 0));
% 	SendMessage(hStaticS, WM_SETFONT, (WPARAM)hFontUserInfoWindow1, MAKELPARAM(false, 0));
% 	SendMessage(hStaticComment1, WM_SETFONT, (WPARAM)hFontBig, MAKELPARAM(false, 0));
% 	//SendMessage(hStaticUserInfo, WM_SETFONT, (WPARAM)hFontBig, MAKELPARAM(false, 0));
% 	SendMessage(hStaticCombo, WM_SETFONT, (WPARAM)hFontUserInfoWindow1, MAKELPARAM(false, 0));

% 	// To Push Button
% 	SendMessage(hButtonNext, WM_SETFONT, (WPARAM)hFontUserInfoWindow1, MAKELPARAM(false, 0));
% 	SendMessage(hNameErase, WM_SETFONT, (WPARAM)hFontUserInfoWindow1, MAKELPARAM(false, 0));
% 	SendMessage(hOldErase, WM_SETFONT, (WPARAM)hFontUserInfoWindow1, MAKELPARAM(false, 0));

% 	// To Radio Button
% 	SendMessage(hRadioMen, WM_SETFONT, (WPARAM)hFontUserInfoWindowRadio, MAKELPARAM(false, 0));
% 	SendMessage(hRadioLady, WM_SETFONT, (WPARAM)hFontUserInfoWindowRadio, MAKELPARAM(false, 0));

% 	// To ComboBox
% 	SendMessage(latedatacombo, WM_SETFONT, (WPARAM)hFontUserInfoWindow1, MAKELPARAM(false, 0));

% 	return true;
% }


% ////////////////////
% //ビットマップをtorchのTensor型に変換する
% /////////////////////
% //torch::Tensor CImageToTensor(const CImage& image)
% //{
% //	int width = image.GetWidth();
% //	int height = image.GetHeight();
% //	int channels = image.GetBPP() / 8;
% //
% //	torch::Tensor tensor = torch::zeros({ 1, 1, height, width });
% //	auto tensor_accessor = tensor.accessor<float, 4>();
% //
% //	for (size_t y = 0; y < height; ++y)
% //	{
% //		for (size_t x = 0; x < width; ++x)
% //		{
% //			COLORREF pixel = image.GetPixel(x, y);
% //			float grayscale_value = (GetRValue(pixel) + GetGValue(pixel) + GetBValue(pixel)) / (3.0 * 255);
% //			tensor_accessor[0][0][y][x] = grayscale_value;
% //		}
% //	}
% //
% //	return tensor;
% //}

% ////////////////////
% //ビットマップのリサイズ
% /////////////////////
% //CImage ResizeImage(const CImage& inputImage, int newWidth, int newHeight) {
% //	
% //	CImage resizedImage;
% //	resizedImage.Create(newWidth, newHeight, inputImage.GetBPP());
% //
% //	HDC hdcResized = resizedImage.GetDC();
% //	HDC hdcInput = inputImage.GetDC();
% //
% //	SetStretchBltMode(hdcResized, HALFTONE);
% //	StretchBlt(hdcResized, 0, 0, newWidth, newHeight, hdcInput,
% //		0, 0, inputImage.GetWidth(), inputImage.GetHeight(), SRCCOPY);
% //
% //	inputImage.ReleaseDC();
% //	resizedImage.ReleaseDC();
% //
% //	return resizedImage;
% //}


% \end{lstlisting}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % 付録C
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{音響信号への遅延生成アプリケーションのソースコード}
% \begin{lstlisting}[caption=main.cpp]
%   //////
% //Delay Click Sound by ASIO Ver. 2 (オーバーラップなし、再生音開始点調整あり、チャタリング考慮、音声遅延あり(別チャンネル再生))
% //////
% #include<windows.h>
% #include<tchar.h>
% #include<stdio.h>
% #include<Xinput.h>
% #include"resource.h"
% #include"ginclude.h"
% #include"asio.h"
% #include"asiodrivers.h"

% // 追加ファイル
% #include<chrono>
% #include<iostream>
% #include<sstream>
% #include<fstream>
% #include<iomanip>
% #include<time.h>
% #include<string>
% #include<ctime>
% #include<vector>
% #include<cmath>
% #include"window.h"
% #include"main.h"
% #include"file.h"
% #include"dialogbox.h"

% // Visualスタイル有効化
% #pragma comment(linker,"\"/manifestdependency:type='win32' \
% name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
% processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

% #pragma comment(lib,"winmm.lib")

% using namespace std;

% LRESULT CALLBACK	windowfunc(HWND, UINT, WPARAM, LPARAM);
% void				bufferswitch(long, ASIOBool);
% ASIOTime* bufferswitchtimeinfo(ASIOTime*, long, ASIOBool);
% void				sampleratedidchange(ASIOSampleRate);
% long				asiomessage(long, long, void*, double*);

% extern AsioDrivers* asioDrivers;
% const TCHAR			szWinName[] = _T("delayclicksound2");
% TCHAR				strASIOInfo[LENSTR], strWaveFileInfo[LENSTR], strBuffInfo[LENSTR];
% ASIODriverInfo		DriverInfo;
% ASIOBufferInfo		BufInfo[MAXNUMINCHS + MAXNUMOUTCHS];
% ASIOChannelInfo		ChannelInfo[MAXNUMINCHS + MAXNUMOUTCHS];
% ASIOCallbacks		CallBacks;
% int					numInChannels, numOutChannels, idDevice, idChannelClick, idChannelSound;
% bool				SupportASIOOutputReady;
% HMMIO				hMmio;
% void* tmpWaveData, * WaveData;
% int					lenWaveData, idxWaveData, BitsPerSample;
% bool				isPlaying, isLoadedDriver, isOpenedDevice, isCreatedBuffer;
% ASIOSampleType		SampleType;
% extern long inlatency, outlatency;
% extern int lenBuffer;
% bool Finished = false; // 実験終了フラグ

% // 追加変数
% extern HWND hStaticNowTime, hStaticTime, hEdit1, htaticNumberOfloops, hStaticNumberOfloops2;
% HFONT hFont1, hFont2, hFont3, hFont4, hFont5;
% RECT recthEdit1 = { 198, 98, 702, 402 };
% int call_count, temp_count;
% bool wavePlayed = false;
% extern int NumberOfloops;
% // 処理時間計測用
% std::chrono::system_clock::time_point start, before_start;
% extern int Num;
% //　時間差を保存するためのベクタ
% vector<string> MarginTime;
% // ボタンの押下回数を保持する変数
% int CountButtonClicked;
% // 親ウィンドウのハンドルを保持
% HWND hParentWindow;
% // 結果の出力先のパスを保持する変数
% string CSVFILENAME;
% // 実験方法の選択
% bool LABNormal;
% int TempNumberOfLoops;
% // 試行回数を保持する変数
% int TempNumberOfTrials;
% // ファイル名
% static char FileNameCSV[MAX_PATH];
% static char FileNameINI[MAX_PATH];

% // タイムスタンプ
% string TimeStampButtonClicked = _T("Nothing");

% // dialogbox.cppと共有
% extern int DelayTiming, DelayTime_ms;
% int DelayTimeUnique;

% // window.cppと共有
% extern RECT rGroupIni;
% extern RECT rGroupIni2;
% //WinMain関数
% int WINAPI WinMain(_In_ HINSTANCE hThisInst, _In_opt_ HINSTANCE hPrevInst, _In_ LPSTR lpszArgs, _In_ int nWinMode)
% {
% 	HWND			hwnd;
% 	MSG				msg;
% 	WNDCLASSEX		wcl;
% 	HACCEL			haccel;

% 	//// 二重起動防止
% 	//HANDLE hMutex = CreateMutex(NULL, TRUE, _T("MyAppMutex"));
% 	//if (GetLastError() == ERROR_ALREADY_EXISTS) {
% 	//	MessageBox(NULL, _T("This Application is already running!"), _T("警告"), MB_OK |  MB_ICONWARNING);
% 	//	return 0;
% 	//}

% 	//ウィンドウクラスの定義
% 	wcl.cbSize = sizeof(WNDCLASSEX);				//WNDCLASSEX構造体のサイズ
% 	wcl.style = 0;									//ウィンドウクラススタイル
% 	wcl.lpfnWndProc = windowfunc;					//ウィンドウ関数
% 	wcl.cbClsExtra = 0;								//ウィンドウクラスのエキストラ
% 	wcl.cbWndExtra = 0;								//ウィンドウインスタンスのエキストラ
% 	wcl.hInstance = hThisInst;						//このプログラムのインスタンスへのハンドル
% 	wcl.hIcon = LoadIcon(NULL, IDI_APPLICATION);	//アイコンへのハンドル
% 	wcl.hCursor = LoadCursor(NULL, IDC_ARROW);		//カーソルへのハンドル
% 	wcl.hbrBackground = (HBRUSH)COLOR_WINDOW;		//背景ブラシへのハンドル
% 	wcl.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1);	//メニュー
% 	wcl.lpszClassName = szWinName;					//ウィンドウクラス名
% 	wcl.hIconSm = LoadIcon(NULL, IDI_WINLOGO);		//スモールアイコンへのハンドル

% 	//ウィンドウクラスの登録
% 	if (!RegisterClassEx(&wcl)) {
% 		return(0);
% 	}

% 	//ウィンドウの生成
% 	hwnd = CreateWindow(
% 		szWinName,				//ウィンドウクラス名
% 		szWinName,				//ウィンドウ名
% 		WS_OVERLAPPEDWINDOW,	//ウィンドウスタイル
% 		CW_USEDEFAULT,			//x座標
% 		CW_USEDEFAULT,			//y座標
% 		CW_USEDEFAULT,			//幅
% 		CW_USEDEFAULT,			//高さ
% 		HWND_DESKTOP,			//親ウィンドウへのハンドル
% 		NULL,					//メニューへのハンドル
% 		hThisInst,				//このプログラムのインスタンスへのハンドル	
% 		NULL					//追加引数
% 	);

% 	// 親ウィンドウハンドルの記憶
% 	hParentWindow = hwnd;

% 	//ウィンドウの表示
% 	ShowWindow(hwnd, nWinMode);
% 	UpdateWindow(hwnd);

% 	//キーボードアクセラレータのロード
% 	haccel = LoadAccelerators(hThisInst, MAKEINTRESOURCE(IDR_ACCELERATOR1));

% 	//メッセージループの生成
% 	while (GetMessage(&msg, NULL, 0, 0)) {
% 		if (!TranslateAccelerator(hwnd, haccel, &msg)) {
% 			TranslateMessage(&msg);
% 			DispatchMessage(&msg);
% 		}
% 	}

% 	return((int)msg.wParam);
% }

% //ウィンドウ関数
% LRESULT CALLBACK windowfunc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
% {
% 	ASIOError		asioresult;
% 	ASIOSampleRate	rate;
% 	char			devnames[MAXNUMDEVS][LENDEVNAME], * tmpnames[MAXNUMDEVS];
% 	TCHAR			str[LENSTR];
% 	long			numinchs, numoutchs, minlenbuffer, maxlenbuffer, preflenbuffer, granularity, tmplong;
% 	int				numdevs, idev, ich, ibuf, isample;
% 	bool			boolresult;
% 	double			tmpdouble;
% 	TCHAR			wavefilename[] = WAVEFILENAME;
% 	MMCKINFO		mmckinfoparent, mmckinfosubchunk;
% 	WAVEFORMATEX	wf;

% 	switch (message) {
% 	case WM_CREATE:
% 		//ウィンドウの初期化
% 		// ウィンドウの作成
% 		CreateControl(hwnd, wparam, lparam);
% 		// 実行ファイルのパス名の取得
% 		TCHAR lpFileName[MAX_PATH];
% 		GetModuleFileName(NULL, lpFileName, sizeof(lpFileName));
% 		// ウィンドウのタイトルを実行ファイルのパス名に変更
% 		SetWindowText(hwnd, lpFileName);
% 		//パラメータの初期化
% 		idDevice = -1;
% 		hMmio = NULL;
% 		tmpWaveData = NULL;
% 		WaveData = NULL;
% 		isPlaying = false;
% 		isLoadedDriver = false;
% 		isOpenedDevice = false;
% 		isCreatedBuffer = false;
% 		idxWaveData = 0;
% 		// 追加
% 		call_count = 1;
% 		temp_count = 0;
% 		NumberOfloops = 3;
% 		TempNumberOfLoops = 1;
% 		CountButtonClicked = 0;
% 		//LABNormal = true;
% 		TempNumberOfTrials = 34;
% 		//ASIOデバイス用メモリ領域の確保
% 		if (asioDrivers == NULL) {
% 			asioDrivers = new AsioDrivers();
% 		}

% 		//ASIOデバイス名の取得
% 		for (idev = 0; idev < MAXNUMDEVS; idev++) {
% 			tmpnames[idev] = devnames[idev];
% 		}
% 		numdevs = asioDrivers->getDriverNames(tmpnames, MAXNUMDEVS);
% 		if (numdevs == 0) {
% 			MessageBox(NULL, _T("asioDrivers->getDriverNames"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}

% 		//ASIOデバイスのドライバのロード
% 		boolresult = asioDrivers->loadDriver(devnames[IDDEV]);
% 		if (boolresult == false) {
% 			isLoadedDriver = false;
% 			_stprintf_s(str, LENSTR, _T("asioDrivers->loadDriver\nDevice Name: %s\n"), devnames[IDDEV]);
% 			MessageBox(NULL, str, _T("Error"), MB_ICONSTOP | MB_OK);
% 		}
% 		else {
% 			isLoadedDriver = true;
% 		}

% 		//ASIOデバイスのオープン
% 		memset(&DriverInfo, 0, sizeof(ASIODriverInfo));
% 		asioresult = ASIOInit(&DriverInfo);
% 		if (asioresult != ASE_OK) {
% 			isOpenedDevice = false;
% 			_stprintf_s(str, LENSTR, _T("ASIOInit\nDevice Name: %s\n"), devnames[IDDEV]);
% 			MessageBox(NULL, str, _T("Error"), MB_ICONSTOP | MB_OK);

% 			//ASIOデバイスのドライバのアンロード
% 			if (isLoadedDriver == true) {
% 				asioDrivers->removeCurrentDriver();
% 				isLoadedDriver = false;
% 			}
% 		}
% 		else {
% 			isOpenedDevice = true;
% 		}

% 		if (isOpenedDevice == false) {
% 			for (idev = 0; idev < numdevs; idev++) {
% 				//				for (idev = numdevs-1; idev >=0; idev--) {
% 				if (idev != IDDEV) {
% 					boolresult = asioDrivers->loadDriver(devnames[idev]);
% 					if (boolresult == false) {
% 						isLoadedDriver = false;
% 						_stprintf_s(str, LENSTR, _T("asioDrivers->loadDriver\nDevice Name: %s\n"), devnames[idev]);
% 						MessageBox(NULL, str, _T("Error"), MB_ICONSTOP | MB_OK);
% 					}
% 					else {
% 						isLoadedDriver = true;
% 					}

% 					//ASIOデバイスのオープン
% 					memset(&DriverInfo, 0, sizeof(ASIODriverInfo));
% 					asioresult = ASIOInit(&DriverInfo);
% 					if (asioresult != ASE_OK) {
% 						isOpenedDevice = false;
% 						_stprintf_s(str, LENSTR, _T("ASIOInit\nDevice Name: %s\n"), devnames[idev]);
% 						MessageBox(NULL, str, _T("Error"), MB_ICONSTOP | MB_OK);

% 						//ASIOデバイスのドライバのアンロード
% 						if (isLoadedDriver == true) {
% 							asioDrivers->removeCurrentDriver();
% 							isLoadedDriver = false;
% 						}
% 					}
% 					else {
% 						isOpenedDevice = true;
% 						break;
% 					}
% 				}
% 			}
% 		}

% 		//ASIOデバイスのサンプリング周波数のサポートの確認
% 		rate = FS;
% 		asioresult = ASIOCanSampleRate(rate);
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIOCanSampleRate"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}

% 		//ASIOデバイスのサンプリング周波数の設定
% 		asioresult = ASIOSetSampleRate(rate);
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIOSetSampleRate"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}

% 		//ASIOデバイスのチャンネル数の取得
% 		asioresult = ASIOGetChannels(&numinchs, &numoutchs);
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIOGetChannels"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}

% 		//ASIOデバイスの録音チャンネル数の設定
% 		if (numinchs <= MAXNUMINCHS) {
% 			numInChannels = numinchs;
% 		}
% 		else {
% 			numInChannels = MAXNUMINCHS;
% 		}

% 		//ASIOデバイスの再生用チャンネル数の設定
% 		if (numoutchs <= MAXNUMOUTCHS) {
% 			numOutChannels = numoutchs;
% 		}
% 		else {
% 			numOutChannels = MAXNUMOUTCHS;
% 		}
% 		if (CHCLICK <= numOutChannels) {
% 			idChannelClick = CHCLICK - 1;
% 		}
% 		else {
% 			idChannelClick = 0;
% 		}
% 		if (CHSOUND <= numOutChannels) {
% 			idChannelSound = CHSOUND - 1;
% 		}
% 		else {
% 			idChannelSound = 0;
% 		}

% 		//ASIOデバイスのバッファサイズの取得
% 		asioresult = ASIOGetBufferSize(&minlenbuffer, &maxlenbuffer, &preflenbuffer, &granularity);
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIOGetBufferSize"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}

% 		//ASIOデバイスのバッファサイズの設定
% 		lenBuffer = preflenbuffer;
% 		// ASIOバッファサイズが16ではない場合、メッセージボックスにて警告を出す
% 		if (lenBuffer != 16) {
% 			_stprintf_s(strBuffInfo, LENSTR, _T("ASIOバッファサイズが「%d」に設定されています。\r\n一度ウィンドウを閉じてから「16」に設定しなおしてください。"), lenBuffer);
% 			MessageBox(NULL, strBuffInfo, _T("ASIOバッファサイズ"), MB_OK | MB_ICONWARNING);
% 		}

% 		//ASIOデバイスの録音用バッファの初期化
% 		for (ich = 0; ich < numInChannels; ich++) {
% 			memset(&(BufInfo[ich]), 0, sizeof(ASIOBufferInfo));
% 			BufInfo[ich].isInput = ASIOTrue;
% 			BufInfo[ich].channelNum = ich;
% 		}

% 		//ASIOデバイスの再生用バッファの初期化
% 		for (ich = 0; ich < numOutChannels; ich++) {
% 			memset(&(BufInfo[numInChannels + ich]), 0, sizeof(ASIOBufferInfo));
% 			BufInfo[numInChannels + ich].isInput = ASIOFalse;
% 			BufInfo[numInChannels + ich].channelNum = ich;
% 		}

% 		//ASIOデバイス用コールバック関数の設定
% 		CallBacks.bufferSwitch = &bufferswitch;
% 		CallBacks.bufferSwitchTimeInfo = &bufferswitchtimeinfo;
% 		CallBacks.sampleRateDidChange = &sampleratedidchange;
% 		CallBacks.asioMessage = &asiomessage;

% 		//ASIOデバイスのバッファの生成
% 		asioresult = ASIOCreateBuffers(BufInfo, numInChannels + numOutChannels, lenBuffer, &CallBacks);
% 		if (asioresult != ASE_OK) {
% 			isCreatedBuffer = false;
% 			MessageBox(NULL, _T("ASIOCreateBuffers"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}
% 		else {
% 			isCreatedBuffer = true;
% 		}

% 		//ASIOデバイスのチャンネル情報の取得
% 		for (ich = 0; ich < numInChannels + numOutChannels; ich++) {
% 			memset(&(ChannelInfo[ich]), 0, sizeof(ASIOChannelInfo));
% 			ChannelInfo[ich].isInput = BufInfo[ich].isInput;
% 			ChannelInfo[ich].channel = BufInfo[ich].channelNum;
% 			asioresult = ASIOGetChannelInfo(&(ChannelInfo[ich]));
% 			if (asioresult != ASE_OK) {
% 				MessageBox(NULL, _T("ASIOGetChannelInfo"), _T("Error"), MB_ICONSTOP | MB_OK);
% 			}
% 		}
% 		SampleType = ChannelInfo[0].type;
% 		switch (SampleType) {
% 		case ASIOSTInt16LSB:
% 			BitsPerSample = 16;
% 			break;
% 		case ASIOSTInt24LSB:
% 			BitsPerSample = 24;
% 			break;
% 		case ASIOSTInt32LSB:
% 			BitsPerSample = 32;
% 			break;
% 		default:
% 			break;
% 		}

% 		//ASIOデバイスのレイテンシの取得
% 		asioresult = ASIOGetLatencies(&inlatency, &outlatency);
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIOGetLatencies"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}

% 		//ASIOOutputReady関数のサポートの確認
% 		asioresult = ASIOOutputReady();
% 		if (asioresult == ASE_OK) {
% 			SupportASIOOutputReady = true;
% 		}
% 		else {
% 			SupportASIOOutputReady = false;
% 		}

% 		//ASIOデバイスの設定内容の確認
% 		ASIOGetSampleRate(&rate);
% 		_stprintf_s(strASIOInfo, LENSTR,
% 			_T("Device Name: %s\n")
% 			_T("Max. No. Input Channels: %d\n")
% 			_T("Max. No. Output Channels: %d\n")
% 			_T("Sampling Frequency: %f Hz\n")
% 			_T("Min. Buffer Size: %d points = %f ms\n")
% 			_T("Max. Buffer Size: %d points = %f ms\n")
% 			_T("Preferred Buffer Size: %d points = %f ms\n")
% 			_T("Allocated Buffer Size: %d points = %f ms\n")
% 			_T("Input Latency: %d points = %f ms\n")
% 			_T("Output Latency: %d points = %f ms\n")
% 			_T("Total Latency: %d points = %f ms\n")
% 			_T("Support \"ASIOOutputReady\": %s"),
% 			DriverInfo.name,
% 			numinchs,
% 			numoutchs,
% 			rate,
% 			minlenbuffer, (double)minlenbuffer * 1000.0 / rate,
% 			maxlenbuffer, (double)maxlenbuffer * 1000.0 / rate,
% 			preflenbuffer, (double)preflenbuffer * 1000.0 / rate,
% 			lenBuffer, (double)lenBuffer * 1000.0 / rate,
% 			inlatency, (double)inlatency * 1000.0 / rate,
% 			outlatency, (double)outlatency * 1000.0 / rate,
% 			inlatency + outlatency, ((double)inlatency + (double)outlatency) * 1000.0 / rate,
% 			SupportASIOOutputReady == true ? _T("Supported.") : _T("Not Supported."));
% 		//MessageBox(NULL, strASIOInfo, _T("ASIO"), MB_OK);

% 		// 遅延時間の設定用コンボボックスの作成とiniファイルの読み込み
% 		ReadIniFile(hwnd, lparam, NULL);
% 		// ループ回数の更新
% 		LateIniFunc(hwnd, wparam);

% 		//WAVEファイルのオープン
% 		if ((hMmio = mmioOpen(wavefilename, NULL, MMIO_READ)) == NULL) {
% 			//ファイルをオープンできなかった場合の処理
% 			_stprintf_s(str, LENSTR, _T("エラー: ファイルを開くことができません\nファイル名: %s"), wavefilename);
% 			MessageBox(hwnd, str, _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}

% 		//ファイルのWAVEチャンクへ移動
% 		memset(&mmckinfoparent, 0, sizeof(MMCKINFO));
% 		mmckinfoparent.fccType = mmioFOURCC('W', 'A', 'V', 'E');
% 		if (mmioDescend(hMmio, &mmckinfoparent, NULL, MMIO_FINDRIFF) != MMSYSERR_NOERROR) {
% 			//チャンクを移動できなかった場合の処理
% 			_stprintf_s(str, LENSTR, _T("エラー: データを読み込むことができません\nファイル名: %s"), wavefilename);
% 			MessageBox(hwnd, str, _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}

% 		//ファイルのfmtチャンクへ移動
% 		memset(&mmckinfosubchunk, 0, sizeof(MMCKINFO));
% 		mmckinfosubchunk.ckid = mmioFOURCC('f', 'm', 't', ' ');
% 		if (mmioDescend(hMmio, &mmckinfosubchunk, &mmckinfoparent, MMIO_FINDCHUNK) != MMSYSERR_NOERROR) {
% 			//チャンクを移動できなかった場合の処理
% 			_stprintf_s(str, LENSTR, _T("エラー: データを読み込むことができません\nファイル名: %s"), wavefilename);
% 			MessageBox(hwnd, str, _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}

% 		//ファイルのデータ形式の読み込み
% 		memset(&wf, 0, sizeof(WAVEFORMATEX));
% 		if (mmioRead(hMmio, (HPSTR)&wf, mmckinfosubchunk.cksize) == -1) {
% 			//ファイルのデータ形式を読み込めなかった場合の処理
% 			_stprintf_s(str, LENSTR, _T("エラー: データを読み込むことができません\nファイル名: %s"), wavefilename);
% 			MessageBox(hwnd, str, _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}

% 		//ファイルのデータ形式の確認
% 		if (wf.wFormatTag != WAVE_FORMAT_PCM) {
% 			//ファイルのデータ形式がPCMではなかった場合の処理
% 			_stprintf_s(str, LENSTR, _T("エラー: PCM形式WAVEデータではないので読み込むことができません\nファイル名: %s"), wavefilename);
% 			MessageBox(hwnd, str, _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}

% 		//ファイルのdataチャンクへ移動
% 		if (mmioAscend(hMmio, &mmckinfosubchunk, 0) != MMSYSERR_NOERROR) {
% 			//チャンクを移動できなかった場合の処理
% 			_stprintf_s(str, LENSTR, _T("エラー: データを読み込むことができません\nファイル名: %s"), wavefilename);
% 			MessageBox(hwnd, str, _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}
% 		memset(&mmckinfosubchunk, 0, sizeof(MMCKINFO));
% 		mmckinfosubchunk.ckid = mmioFOURCC('d', 'a', 't', 'a');
% 		if (mmioDescend(hMmio, &mmckinfosubchunk, &mmckinfoparent, MMIO_FINDCHUNK) != MMSYSERR_NOERROR) {
% 			//チャンクを移動できなかった場合の処理
% 			_stprintf_s(str, LENSTR, _T("エラー: データを読み込むことができません\nファイル名: %s"), wavefilename);
% 			MessageBox(hwnd, str, _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}
% 		lenWaveData = mmckinfosubchunk.cksize / wf.nBlockAlign;

% 		//メッセージボックスへのテキストの出力
% 		_stprintf_s(strWaveFileInfo, LENSTR,
% 			_T("File Name: %s\n")
% 			_T("Sampling Frequency: %d Hz\n")
% 			_T("Bits per Sample: %d bits\n")
% 			_T("Number of Channels: %d channels\n")
% 			_T("Length of Data: %d samples"),
% 			wavefilename, wf.nSamplesPerSec, wf.wBitsPerSample, wf.nChannels, lenWaveData);
% 		//MessageBox(NULL, strWaveFileInfo, _T("Read a Wave File"), MB_OK);

% 		//WAVEデータ用バッファの生成
% 		tmpWaveData = (void*)malloc(mmckinfosubchunk.cksize);
% 		WaveData = (void*)malloc(lenWaveData * (BitsPerSample / 8));
% 		if (tmpWaveData == NULL || WaveData == NULL) {
% 			//バッファを生成できなかった場合の処理
% 			MessageBox(hwnd, _T("エラー: メモリーが足りません"), _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}

% 		//WAVEデータの読み込み
% 		if (mmioRead(hMmio, (HPSTR)tmpWaveData, mmckinfosubchunk.cksize) <= 0) {
% 			//データを読み込めなかった場合の処理
% 			_stprintf_s(str, LENSTR, _T("エラー: データを読み込むことができません\nファイル名: %s"), wavefilename);
% 			MessageBox(hwnd, str, _T("ファイルを開く"), MB_ICONSTOP | MB_OK);
% 			return(0);
% 		}

% 		//WAVEファイルのクローズ
% 		if (hMmio != NULL) {
% 			mmioClose(hMmio, 0);
% 			hMmio = NULL;
% 		}

% 		//WAVEデータの変換
% 		for (isample = 0; isample < lenWaveData; isample++) {
% 			tmpdouble = 0.0;
% 			for (ich = 0; ich < wf.nChannels; ich++) {
% 				//WAVEデータのshort int型への変換
% 				switch (wf.wBitsPerSample) {
% 				case 8:
% 					tmplong = ((long)((unsigned char*)tmpWaveData)[isample * wf.nChannels + ich] - 0x80L) * 0x100L;
% 					break;
% 				case 16:
% 					tmplong = (long)((short int*)tmpWaveData)[isample * wf.nChannels + ich];
% 					break;
% 				}
% 				if (wf.nChannels > 1) {
% 					tmpdouble += (double)tmplong;
% 				}
% 			}
% 			if (wf.nChannels > 1) {
% 				tmplong = (long)(tmpdouble / (double)wf.nChannels);
% 			}

% 			//WAVEデータのshort int型からの変換
% 			switch (SampleType) {
% 			case ASIOSTInt16LSB:
% 				((char*)WaveData)[isample * 2] = (char)tmplong;
% 				tmplong >>= 8;
% 				((char*)WaveData)[isample * 2 + 1] = (char)tmplong;
% 				break;
% 			case ASIOSTInt24LSB:
% 				tmplong *= 0x100L;
% 				((char*)WaveData)[isample * 3] = (char)tmplong;
% 				tmplong >>= 8;
% 				((char*)WaveData)[isample * 3 + 1] = (char)tmplong;
% 				tmplong >>= 8;
% 				((char*)WaveData)[isample * 3 + 2] = (char)tmplong;
% 				break;
% 			case ASIOSTInt32LSB:
% 				tmplong *= 0x10000L;
% 				((char*)WaveData)[isample * 4] = (char)tmplong;
% 				tmplong >>= 8;
% 				((char*)WaveData)[isample * 4 + 1] = (char)tmplong;
% 				tmplong >>= 8;
% 				((char*)WaveData)[isample * 4 + 2] = (char)tmplong;
% 				tmplong >>= 8;
% 				((char*)WaveData)[isample * 4 + 3] = (char)tmplong;
% 				break;
% 			default:
% 				break;
% 			}
% 		}

% 		//WAVEデータ用バッファの解放
% 		if (tmpWaveData != NULL) {
% 			free(tmpWaveData);
% 			tmpWaveData = NULL;
% 		}

% 		// フォントの初期設定
% 		OnFont(hwnd);

% 		//ASIOデバイスの再生用バッファの初期化
% 		for (ich = 0; ich < numOutChannels; ich++) {
% 			for (ibuf = 0; ibuf < NUMASIOBUFFERS; ibuf++) {
% 				switch (SampleType) {
% 				case ASIOSTInt16LSB:
% 					memset(BufInfo[numInChannels + ich].buffers[ibuf], 0, lenBuffer * 2);
% 					break;
% 				case ASIOSTInt24LSB:
% 					memset(BufInfo[numInChannels + ich].buffers[ibuf], 0, lenBuffer * 3);
% 					break;
% 				case ASIOSTInt32LSB:
% 					memset(BufInfo[numInChannels + ich].buffers[ibuf], 0, lenBuffer * 4);
% 					break;
% 				default:
% 					break;
% 				}
% 			}
% 		}

% 		//ASIOデバイスの開始
% 		asioresult = ASIOStart();
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIOStart"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}
% 		break;

% 	case WM_COMMAND:
% 		OnCommand(hwnd, wparam, lparam);
% 		break;
% 	case WM_CLOSE:
% 		//プログラムの終了
% 		if (IDYES == MessageBox(hwnd, _T("終了しますか？"), _T("終了確認"), MB_YESNO)) {
% 			DestroyWindow(hwnd);
% 		}
% 		break;
% 	case WM_PAINT:
% 	{
% 		PAINTSTRUCT ps;
% 		HDC hdc = BeginPaint(hwnd, &ps);
% 		OnPaint(hwnd, hdc);

% 		EndPaint(hwnd, &ps);
% 	}
% 	break;

% 	case WM_DESTROY:

% 		// 後始末
% 		DeleteObject(hFont1);
% 		DeleteObject(hFont2);
% 		DeleteObject(hFont3);
% 		DeleteObject(hFont4);
% 		DeleteObject(hFont5);

% 		//ASIOデバイスの停止
% 		asioresult = ASIOStop();
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIOStop"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}

% 		//ASIOデバイスのバッファの解放
% 		asioresult = ASIODisposeBuffers();
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIODisposeBuffers"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}

% 		//ASIOデバイスのクローズ
% 		if (isOpenedDevice == true) {
% 			asioresult = ASIOExit();
% 			if (asioresult != ASE_OK) {
% 				MessageBox(NULL, _T("ASIOExit"), _T("Error"), MB_ICONSTOP | MB_OK);
% 			}
% 			isOpenedDevice = false;
% 		}

% 		//ASIOデバイスのドライバのアンロード
% 		if (isLoadedDriver == true) {
% 			asioDrivers->removeCurrentDriver();
% 			isLoadedDriver = false;
% 		}

% 		//ASIOデバイス用メモリ領域の解放
% 		if (asioDrivers != NULL) {
% 			delete asioDrivers;
% 		}

% 		//WAVEデータ用バッファの解放
% 		if (tmpWaveData != NULL) {
% 			free(tmpWaveData);
% 			tmpWaveData = NULL;
% 		}
% 		if (WaveData != NULL) {
% 			free(WaveData);
% 			WaveData = NULL;
% 		}

% 		//WAVEファイルのクローズ
% 		if (hMmio != NULL) {
% 			mmioClose(hMmio, 0);
% 			hMmio = NULL;
% 		}

% 		PostQuitMessage(0);
% 		break;

% 	default:
% 		return(DefWindowProc(hwnd, message, wparam, lparam));
% 	}

% 	return(0);
% }



% //ASIOデバイスのバッファ処理用コールバック関数
% void bufferswitch(long index, ASIOBool processNow) {
% 	ASIOError	asioresult;
% 	int			tmplenbuffer, isample, position;
% 	double	tmpdouble;
% 	long		tmplong;
	

% 	//録音データ(クリック信号)の変換
% 	for (isample = 0; isample < lenBuffer; isample++) {
% 		switch (SampleType) {
% 		case ASIOSTInt16LSB:
% 			tmplong = 0L;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 2 + 1];
% 			tmplong <<= 8;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 2];
% 			tmpdouble = (double)tmplong / (double)0x8000L;
% 			break;
% 		case ASIOSTInt24LSB:
% 			tmplong = 0L;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 3 + 2];
% 			tmplong <<= 8;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 3 + 1];
% 			tmplong <<= 8;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 3];
% 			tmpdouble = (double)tmplong / (double)0x800000L;
% 			break;
% 		case ASIOSTInt32LSB:
% 			tmplong = 0L;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 4 + 3];
% 			tmplong <<= 8;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 4 + 2];
% 			tmplong <<= 8;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 4 + 1];
% 			tmplong <<= 8;
% 			tmplong += ((unsigned char*)(BufInfo[idChannelClick].buffers[index]))[isample * 4];
% 			tmpdouble = (double)tmplong / (double)0x80000000UL;
% 			break;
% 		default:
% 			tmpdouble = 0.0;
% 			break;
% 		}

% 		if (tmpdouble >= THRESH || -tmpdouble >= THRESH) {
% 			if (isPlaying == false || idxWaveData + isample > (FS * LENCHATTERING) / 1000) {
% 				// パラメータの設定
% 				isPlaying = true;
% 				idxWaveData = 0;
% 				position = isample;
% 				call_count = 1;
% 				// 前回のボタン押下時刻の取得
% 				if (CountButtonClicked)  before_start = start;
% 				// 現在時刻の取得
% 				start = std::chrono::system_clock::now();
% 				// エディットボックスにボタンの押下時刻を表示
% 				SendNowTimeToEdit(hEdit1, getMilliTime(start));
% 				if (CountButtonClicked) {
% 					// 前回のボタン押下時刻との時間差を計算し、表示
% 					auto time = start - before_start;
% 					SendMarginTimeToEdit(time);
% 					// ベクター配列に結果を保存
% 					GetMarginTime(time);
% 					// テキストの最後にカーソルを移動
% 					ScrollToBottom(hEdit1);
% 				}
% 				if (!LABNormal) {
% 					/////////////////////////
% 					// 実験方法が変則の場合
% 					// ///////////////////////
% 					/*ここにクリック音の再生タイミングをずらすためのプログラムを書く。*/
% 					if (!((CountButtonClicked+1) % DelayTiming)) {
% 						// 再生タイミングをずらす（1回目以外）
% 						CalcLateNumberOfloops(hParentWindow, &DelayTimeUnique, DelayTime_ms, lenBuffer, FS, inlatency, outlatency);
% 						NumberOfloops = NumberOfloops + DelayTimeUnique;
% 					}
% 					else if(NumberOfloops != TempNumberOfLoops) {
% 						NumberOfloops = TempNumberOfLoops;
% 					}
% 				}
% 				// 実験終了のためのメッセージボックスを出力
% 				if (CountButtonClicked == TempNumberOfTrials) {
% 					string TempNumberString = _T("指定回数に達しました。");
% 					MessageBox(NULL, TempNumberString.c_str(), _T("終了の合図"), MB_OK);
% 					SetStddev2Window(MarginTime);                                                   // 標準偏差を計算し、ウィンドウに表示
					
% 					// 無効化
% 					EnableWindow(GetDlgItem(hParentWindow, ID_LATESETTING), FALSE);
% 					EnableWindow(GetDlgItem(hParentWindow, ID_LATESETTING_2), FALSE);
% 					EnableWindow(GetDlgItem(hParentWindow, ID_LATEINI_2), FALSE);
% 					EnableWindow(GetDlgItem(hParentWindow, ID_EDIT_LATEDATA_TIMING), FALSE);
% 					EnableWindow(GetDlgItem(hParentWindow, ID_LATEINI), FALSE);
% 				}
% 				// ボタンの押下回数を更新
% 				SendCountButtonClicked(GetDlgItem(hParentWindow, ID_STATIC_COUNTBUTTONCLICKED_2), CountButtonClicked);
% 				Finished = true; // 音が鳴らないようにするための変数
% 				break;
% 			}
% 		}
% 	}
% 	if (isample == lenBuffer) {
% 		position = 0;
% 	}

% 	//ASIOデバイスのクリック音再生用バッファのクリア
% 	switch (SampleType) {
% 	case ASIOSTInt16LSB:
% 		memset(BufInfo[numInChannels + idChannelClick].buffers[index], 0, lenBuffer * 2);
% 		break;
% 	case ASIOSTInt24LSB:
% 		memset(BufInfo[numInChannels + idChannelClick].buffers[index], 0, lenBuffer * 3);
% 		break;
% 	case ASIOSTInt32LSB:
% 		memset(BufInfo[numInChannels + idChannelClick].buffers[index], 0, lenBuffer * 4);
% 		break;
% 	default:
% 		break;
% 	}

% 	if (isPlaying == true) {
% 		if (lenBuffer - position > lenWaveData - idxWaveData) {
% 			tmplenbuffer = lenWaveData - idxWaveData;
% 		}
% 		else {
% 			tmplenbuffer = lenBuffer - position;
% 		}
% 		// ボタンが押されてから(NumberOfloops)回目のbufferswitch呼び出し時にWaveデータをコピー
% 		if (call_count % NumberOfloops != 0) {
% 			// 録音データ(音声信号)のコピー（出力バッファー2にコピー）
% 			switch (SampleType) {
% 			case ASIOSTInt16LSB:
% 				memcpy_s(BufInfo[numInChannels + idChannelClick].buffers[index], lenBuffer * 2, BufInfo[idChannelSound].buffers[index], lenBuffer * 2);
% 				break;
% 			case ASIOSTInt24LSB:
% 				memcpy_s(BufInfo[numInChannels + idChannelClick].buffers[index], lenBuffer * 3, BufInfo[idChannelSound].buffers[index], lenBuffer * 3);
% 				break;
% 			case ASIOSTInt32LSB:
% 				memcpy_s(BufInfo[numInChannels + idChannelClick].buffers[index], lenBuffer * 4, BufInfo[idChannelSound].buffers[index], lenBuffer * 4);
% 				break;
% 			default:
% 				break;
% 			}
% 			call_count++;
% 		}
% 		else {
% 			//WAVEデータのクリック音再生用バッファへのコピー（出力バッファー1と2にコピー）
% 			switch (SampleType) {
% 			case ASIOSTInt16LSB:
% 				memcpy_s((void*)&(((char*)(BufInfo[numInChannels + idChannelClick].buffers[index]))[position * 2]), tmplenbuffer * 2, (void*)&(((char*)WaveData)[idxWaveData * 2]), tmplenbuffer * 2);
% 				memcpy_s((void*)&(((char*)(BufInfo[numInChannels + idChannelSound].buffers[index]))[position * 2]), tmplenbuffer * 2, (void*)&(((char*)WaveData)[idxWaveData * 2]), tmplenbuffer * 2);
% 				break;
% 			case ASIOSTInt24LSB:
% 				memcpy_s((void*)&(((char*)(BufInfo[numInChannels + idChannelClick].buffers[index]))[position * 3]), tmplenbuffer * 3, (void*)&(((char*)WaveData)[idxWaveData * 3]), tmplenbuffer * 3);
% 				memcpy_s((void*)&(((char*)(BufInfo[numInChannels + idChannelSound].buffers[index]))[position * 3]), tmplenbuffer * 3, (void*)&(((char*)WaveData)[idxWaveData * 3]), tmplenbuffer * 3);
% 				break;
% 			case ASIOSTInt32LSB:
% 				memcpy_s((void*)&(((char*)(BufInfo[numInChannels + idChannelClick].buffers[index]))[position * 4]), tmplenbuffer * 4, (void*)&(((char*)WaveData)[idxWaveData * 4]), tmplenbuffer * 4);
% 				memcpy_s((void*)&(((char*)(BufInfo[numInChannels + idChannelSound].buffers[index]))[position * 4]), tmplenbuffer * 4, (void*)&(((char*)WaveData)[idxWaveData * 4]), tmplenbuffer * 4);
% 				break;
% 			default:
% 				break;
% 			}
% 			idxWaveData += tmplenbuffer;
% 			if (idxWaveData >= lenWaveData) {
% 				/////////////////////
% 				//パラメータの設定
% 				////////////////////
% 				isPlaying = false;
% 				idxWaveData = 0;
% 				call_count = 1;
% 			}
			
% 		}
% 	}
% 		//録音データ(音声信号)のコピー（出力バッファー1にコピー）
% 		switch (SampleType) {
% 		case ASIOSTInt16LSB:
% 			memcpy_s(BufInfo[numInChannels + idChannelSound].buffers[index], lenBuffer * 2, BufInfo[idChannelSound].buffers[index], lenBuffer * 2);
% 			break;
% 		case ASIOSTInt24LSB:
% 			memcpy_s(BufInfo[numInChannels + idChannelSound].buffers[index], lenBuffer * 3, BufInfo[idChannelSound].buffers[index], lenBuffer * 3);
% 			break;
% 		case ASIOSTInt32LSB:
% 			memcpy_s(BufInfo[numInChannels + idChannelSound].buffers[index], lenBuffer * 4, BufInfo[idChannelSound].buffers[index], lenBuffer * 4);
% 			break;
% 		default:
% 			break;
% 		}
	

% 	//再生用バッファの準備完了の通知
% 	if (SupportASIOOutputReady == true) {
% 		asioresult = ASIOOutputReady();
% 		if (asioresult != ASE_OK) {
% 			MessageBox(NULL, _T("ASIOOutputReady"), _T("Error"), MB_ICONSTOP | MB_OK);
% 		}
% 	}
% }

% // 遅延時間[ms]を表示
% bool SendMarginTimeToEdit(std::chrono::system_clock::duration time) {

% 	auto msec = std::chrono::duration_cast<std::chrono::milliseconds>(time).count();
% 	std::string string_msec = std::to_string(msec);
% 	std::string b = _T("時間差[ms]: ");
% 	string_msec = b + string_msec;
% 	const char* str_msec = string_msec.c_str();
% 	SendNowTimeToEdit(hEdit1, str_msec);
	

% 	return true;
% }

% // 時間差を配列に代入していくための関数
% bool GetMarginTime(std::chrono::system_clock::duration time) {

% 	string stringTime;

% 	auto msec = std::chrono::duration_cast<std::chrono::milliseconds>(time).count();
	
% 	stringTime = to_string(msec);
% 	//else stringTime = _T("false"); 

% 	MarginTime.push_back(stringTime);

% 	return true;
% }

% // 得られた時間差をcsvファイルに書き込むための関数
% bool WriteToCSV(HWND hwnd, vector<string>& MarginTime, const string& filename) {
% 	char Temp[MAX_PATH];
% 	_stprintf_s(Temp, MAX_PATH,
% 		_T("以下のファイルに書き込みました。\r\n%s"),
% 		filename.c_str());

% 	// 出力ファイルストリームオブジェクトを作成
% 	// ファイルが存在しない場合は新たにファイルを作成、存在する場合はファイルの末尾に書き込み
% 		ofstream file(filename, ios::app);
% 		// カンマ区切りでストリームに送る
% 		for (size_t i = 0; i < MarginTime.size(); ++i) {
% 			file << MarginTime[i];
% 			if (i != MarginTime.size() - 1) {
% 				file << ",";
% 			}
% 		}
% 		file << "\n";
% 		file.close();

% 		// ベクターの中身の削除
% 		MarginTime.clear();
% 		// 書き込み確認
% 		MessageBox(hwnd, Temp, _T("結果の出力先の確認"), MB_OK);
% 		// 押下回数の更新
% 		CountButtonClicked = 0;
% 		SetWindowText(GetDlgItem(hwnd, ID_STATIC_COUNTBUTTONCLICKED_2), _T("0"));
% 		// エディットボックスの表示内容をクリア
% 		SetWindowText(hEdit1, _T(""));

% 	return true;
% }

% // ベクターの中身を削除
% bool ClearMarginTime(HWND hwnd, vector<string>& MarginTime) {

% 	// ベクターの中身の削除
% 	if (!MarginTime.empty()) {
% 		MarginTime.clear();
% 		// ボタンの押下回数の更新
% 		CountButtonClicked = 0;
% 		SetWindowText(GetDlgItem(hwnd, ID_STATIC_COUNTBUTTONCLICKED_2), _T("0"));
% 		// エディットボックスの表示内容をクリア
% 		SetWindowText(hEdit1, _T(""));
% 	}
% 	else
% 	{
% 		MessageBox(hwnd, _T("配列には何も入ってません。"), NULL, MB_OK);
% 	}
% 	return true;
% }

% // ボタンの押下回数の更新
% bool SendCountButtonClicked(HWND hStatic, int& CountButtonClicked) {
% 	// ボタンの押下回数の送信
% 	CountButtonClicked++;
% 	string CountString = to_string(CountButtonClicked);
% 	SetWindowText(hStatic, CountString.c_str());
% 	return true;
% }

% // エディットボックスに時刻を表示
% bool SendNowTimeToEdit(HWND hwndEdit, const char* timeStr) {

% 	// エディットボックス内の現在の文字列を取得
% 	int length = GetWindowTextLength(hwndEdit);
% 	char* existingText = new char[length + 1];
% 	GetWindowText(hwndEdit, existingText, length + 1);

% 	char* newText = new char[length + strlen(timeStr) + 3];
% 	sprintf(newText, "%s\r\n%s", existingText, timeStr);

% 	// 新しくエディットボックスに文字をセット
% 	SetWindowText(hwndEdit, newText);

% 	// 後始末
% 	delete[] existingText;
% 	delete[] newText;

% 	return true;
% }

% // 現在時刻をミリ秒まで取得（同時に呼び出されないようにする）
% const char* getMilliTime(std::chrono::system_clock::time_point now) {
% 	// 現在の時刻を取得
% 	//auto now = std::chrono::system_clock::now();

% 	// エポックからの経過時間を秒とミリ秒に分割
% 	auto seconds = std::chrono::time_point_cast<std::chrono::seconds>(now);
% 	auto milliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(now - seconds);

% 	// std::time_tに変換
% 	std::time_t tt = std::chrono::system_clock::to_time_t(seconds);

% 	// 時刻をローカルタイムに変換
% 	std::tm* tm = std::localtime(&tt); // この関数はスレッドセーフではない

% 	// 指定された形式で出力
% 	std::ostringstream oss, oss2;
% 	oss << std::put_time(tm, "%H:%M:%S") << '.'
% 		<< std::setfill('0') << std::setw(3) << milliseconds.count();

% 	// ファイル出力用
% 	oss2 << put_time(tm, "%m-%d");

% 	// 結果をstatic std::stringに変換
% 	static string str, str2, a;
	
% 	str = oss.str();
% 	str2 = oss2.str();

% 	// グローバル変数に時刻を記憶（csvファイルに書き込む際に必要)
% 	TimeStampButtonClicked = str2;
% 	a = _T("ボタン押下時刻: ");
% 	// 結果のconst char*を返す
% 	str = a + str;
% 	return str.c_str();
% }




% //ASIOデバイスのバッファ処理時のタイムスタンプ用コールバック関数
% ASIOTime* bufferswitchtimeinfo(ASIOTime* params, long doubleBufferIndex, ASIOBool directProcess)
% {
	
% 	return(0L);
% }

% //ASIOデバイスのサンプリング周波数変更検出用コールバック関数
% void sampleratedidchange(ASIOSampleRate sRate)
% {
% 	return;
% }

% //ASIOデバイスからのメッセージの処理用コールバック関数
% long asiomessage(long selector, long value, void* message, double* opt)
% {
% 	return(0L);
% }



% // NumberOfloopsの表示
% bool DispNumberOfloops() {

% 	return true;
% }
% // フォントの設定
% bool OnFont(HWND hwnd) {

% 	hFont1 = CreateFont(25, 0, 0, 0, FW_MEDIUM, false, false, false, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, (VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hFont2 = CreateFont(22, 0, 0, 0, FW_MEDIUM, false, false, false, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, (VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hFont3 = CreateFont(45, 0, 0, 0, FW_BOLD, false, false, false, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, (VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hFont4 = CreateFont(18, 0, 0, 0, FW_MEDIUM, false, false, false, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, (VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	hFont5 = CreateFont(30, 0, 0, 0, FW_BOLD, false, false, false, SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
% 		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, (VARIABLE_PITCH | FF_DONTCARE), _T("メイリオ"));

% 	SendMessage(hEdit1, WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	SendMessage(hStaticTime, WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	// ステティックコントロール
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_NUMBERDELAY1), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_NUMBERDELAY2), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_COUNTBUTTONCLICKED), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_COUNTBUTTONCLICKED_2), WM_SETFONT, (WPARAM)hFont3, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_NUMBERDELAY1), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_NUMBERDELAY2), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_GROUP_SETTING), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_BPM), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_BPMNUM), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_TRIALS), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_TRIALS_NUM), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_LAB), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_NORMALORIRREG), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_GROUP_LATEDATA), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_GROUP_LATEDATA_2), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_FILENAME), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_OLD), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_NAME), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_GROUP_SUBJECTINFO), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_EDIT_OLD), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_EDIT_NAME), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_COMBO_MS), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_COMBO_MS_2), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_LATEDATATIMING), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_STDDEV), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));

% 	// コンボボックス
% 	SendMessage(GetDlgItem(hwnd, ID_LATEINI), WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_LATEINI_2), WM_SETFONT, (WPARAM)hFont4, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_LATESETTING), WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_LATESETTING_2), WM_SETFONT, (WPARAM)hFont1, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_STATIC_LATESETTING_2), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));

% 	// プッシュボタン
% 	SendMessage(GetDlgItem(hwnd, ID_BUTTON_CSV), WM_SETFONT, (WPARAM)hFont5
% 		, MAKELPARAM(false, 0));
	
% 	// エディットボックス
% 	SendMessage(GetDlgItem(hwnd, ID_EDIT_LATEDATA_TIMING), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));
% 	SendMessage(GetDlgItem(hwnd, ID_EDIT_FILEPATH), WM_SETFONT, (WPARAM)hFont2, MAKELPARAM(false, 0));

% 	return true;
% }



% // コンボボックスにフォーカスが来た時
% bool LateIniFunc(HWND hWnd, WPARAM wParam) {

% 		//コンボボックスで現在選択されている項目のインデックスを取得
% 		Num = GetNowComboStr(hWnd, ID_LATESETTING);
% 		// NumberOfloopsを計算
% 		CalcLateNumberOfloops(hWnd, &NumberOfloops, Num, lenBuffer, FS, inlatency, outlatency);
% 		// NumberOfloopsをstd::string型に変換
% 		string stringnum = to_string(NumberOfloops);
% 		// 画面上に表示
% 		SetWindowText(hStaticNumberOfloops2, stringnum.c_str());
% 		// グローバル変数にNumberOfLoopsの値を記憶させる
% 		TempNumberOfLoops = NumberOfloops;

% 	return true;
% }

% // コンボボックス(変則var)の項目が変更された時
% bool LateIniFunc_2(HWND hWnd, WPARAM wParam) {

% 	//コンボボックスで現在選択されている項目のインデックスを取得
% 	int LocalDelayTIme = GetNowComboStr(hWnd, ID_LATESETTING_2);
% 	// 遅延のタイミング
% 	char* lpstringDelayTiming = new char[50];
% 	GetWindowText(GetDlgItem(hWnd, ID_EDIT_LATEDATA_TIMING), lpstringDelayTiming, 50);
% 	DelayTiming = atoi(lpstringDelayTiming);

% 	DelayTime_ms = LocalDelayTIme;

% 	delete[] lpstringDelayTiming;

% 	return true;
% }

% // コンボボックス1で選択されたキー名に対応した遅延時間をコンボボックスに詰める。
% bool SendLate2Combo(HWND hwnd, WPARAM wParam, char* IniFilepath) {
% 		//コンボボックスで現在選択されている項目のインデックスを取得
% 		int intCurrentIndex = SendMessage(GetDlgItem(hwnd, (int)ID_LATEINI), CB_GETCURSEL, 0, 0);

% 		// 現在選択されている項目のの文字列の長さを取得
% 		int intTxtLen = SendMessage(GetDlgItem(hwnd, (int)ID_LATEINI), CB_GETLBTEXTLEN, intCurrentIndex, 0);

% 		if (intTxtLen != CB_ERR){
% 			char* pszBuf = new char[intTxtLen + 1];
% 			if (SendMessage(GetDlgItem(hwnd, ID_LATEINI), CB_GETLBTEXT, intCurrentIndex, (LPARAM)pszBuf) != CB_ERR) {
% 				char latedata[256];
% 				int len = strlen(IniFilepath);
% 				// IniFileを指定していない場合は、変数の長さが0になるので、デフォルトのIniFileを指定する
% 				if (len == 0){
% 					char Path[MAX_PATH + 1];
% 					char settingpath[MAX_PATH + 1];
% 					if (GetModuleFileName(NULL, Path, MAX_PATH) != 0) {
% 						char drive[MAX_PATH + 1], dir[MAX_PATH + 1], fname[MAX_PATH + 1], ext[MAX_PATH + 1];
% 						// パス名を分解
% 						_splitpath(Path, drive, dir, fname, ext);
% 						_stprintf_s(settingpath, MAX_PATH + 1, INIFILEDEFNAME, drive, dir);
% 						//MessageBox(hwnd, settingpath, _T("結果の出力先の確認"), MB_OK);
% 					}
% 					// iniファイルの読み込み
% 					GetPrivateProfileString(pszBuf, _T("data"), _T("Error"), latedata, sizeof(latedata), settingpath);
% 				}
% 				else {
% 					GetPrivateProfileString(pszBuf, _T("data"), _T("Error"), latedata, sizeof(latedata), IniFilepath);
% 				}

% 				// コンボボックスの中身を消去
% 				while (SendMessage(GetDlgItem(hwnd, (int)ID_LATESETTING), CB_GETCOUNT, 0, 0)){
% 					SendMessage(GetDlgItem(hwnd, (int)ID_LATESETTING), CB_DELETESTRING, 0, 0);
% 				}

% 				stringstream ss, tt;
% 				ss << latedata;
% 				string s, t;

% 				int i = 0;
% 				while (getline(ss, s, ',')) {
% 					char* cstr = new char[s.size() + 1];
% 					char_traits<char>::copy(cstr, s.c_str(), s.size() + 1);
% 					// コンボボックスに文字列を挿入
% 					SendMessage(GetDlgItem(hwnd, ID_LATESETTING), CB_INSERTSTRING, i, (LPARAM)cstr);
% 					i++;
% 				}
% 				// コンボボックスに先頭の要素をセット
% 				SendMessage(GetDlgItem(hwnd, ID_LATESETTING), CB_SETCURSEL, 0, 0);
% 			}
			
% 			delete[] pszBuf;
% 		}
	
% 	return true;
% }
% // コンボボックス1で選択されたキー名に対応した遅延時間をコンボボックスに詰める。
% bool SendLate2Combo_2(HWND hwnd, WPARAM wParam, char* IniFilepath) {


% 	//コンボボックスで現在選択されている項目のインデックスを取得
% 	int intCurrentIndex = SendMessage(GetDlgItem(hwnd, (int)ID_LATEINI_2), CB_GETCURSEL, 0, 0);

% 	// 現在選択されている項目のの文字列の長さを取得
% 	int intTxtLen = SendMessage(GetDlgItem(hwnd, (int)ID_LATEINI_2), CB_GETLBTEXTLEN, intCurrentIndex, 0);

% 	if (intTxtLen != CB_ERR) {
% 		char* pszBuf = new char[intTxtLen + 1];
% 		if (SendMessage(GetDlgItem(hwnd, ID_LATEINI_2), CB_GETLBTEXT, intCurrentIndex, (LPARAM)pszBuf) != CB_ERR) {
% 			char latedata[256];
% 			if (IniFilepath[0] == _T('\0')) {
% 				char Path[MAX_PATH + 1];
% 				char settingpath[MAX_PATH + 1];
% 				if (GetModuleFileName(NULL, Path, MAX_PATH) != 0) {
% 					char drive[MAX_PATH + 1], dir[MAX_PATH + 1], fname[MAX_PATH + 1], ext[MAX_PATH + 1];
% 					// パス名を分解
% 					_splitpath(Path, drive, dir, fname, ext);
% 					_stprintf_s(settingpath, MAX_PATH + 1, INIFILEDEFNAME, drive, dir);
% 				}
% 				// iniファイルの読み込み
% 				GetPrivateProfileString(pszBuf, _T("data"), _T("Error"), latedata, sizeof(latedata), settingpath);
% 			}
% 			else {
% 				GetPrivateProfileString(pszBuf, _T("data"), _T("Error"), latedata, sizeof(latedata), IniFilepath);
% 			}
% 			// コンボボックスの中身を消去
% 			while (SendMessage(GetDlgItem(hwnd, (int)ID_LATESETTING_2), CB_GETCOUNT, 0, 0)) {
% 				SendMessage(GetDlgItem(hwnd, (int)ID_LATESETTING_2), CB_DELETESTRING, 0, 0);
% 			}

% 			stringstream ss, tt;
% 			ss << latedata;
% 			string s, t;

% 			int i = 0;
% 			while (getline(ss, s, ',')) {
% 				char* cstr = new char[s.size() + 1];
% 				char_traits<char>::copy(cstr, s.c_str(), s.size() + 1);
% 				// コンボボックスに文字列を挿入
% 				SendMessage(GetDlgItem(hwnd, ID_LATESETTING_2), CB_INSERTSTRING, i, (LPARAM)cstr);
% 				i++;
% 			}
% 			// コンボボックスに先頭の要素をセット
% 			SendMessage(GetDlgItem(hwnd, ID_LATESETTING_2), CB_SETCURSEL, 0, 0);
% 		}

% 		delete[] pszBuf;
% 	}

% 	return true;
% }

% // コンボボックスで現在選択されている項目の文字列を取得する関数
% int GetNowComboStr(HWND hWnd, int comboID) {

% 	int LocalNum;
% 	//コンボボックスで現在選択されている項目のインデックスを取得
% 	int intCurrentIndex = SendMessage(GetDlgItem(hWnd, (int)comboID), CB_GETCURSEL, 0, 0);

% 	// コンボボックスの現在選択されている項目の文字列の長さを取得
% 	int intTxtLen = SendMessage(GetDlgItem(hWnd, (int)comboID), CB_GETLBTEXTLEN, intCurrentIndex, 0);

% 	if (intTxtLen != CB_ERR) {
% 		char* pszBuf = new char[intTxtLen + 1];
% 		// コンボボックスの一覧から選択した項目の文字列を取得
% 		if (SendMessage(GetDlgItem(hWnd, (int)comboID), CB_GETLBTEXT, intCurrentIndex, (LPARAM)pszBuf) != CB_ERR) {
% 			// char*型をint型に変換
% 			 LocalNum = atoi(pszBuf);
% 		}

% 		delete[] pszBuf;
% 	}
% 	return LocalNum;
% }


% // コンボボックスの選択項目から遅延時間を算出
% bool CalcLateNumberOfloops(HWND hwnd, int* NumberOfloops, int  Num, int lenbuffer, int rate, long inlatency, long outlatency){
% 	/* 引数: ウィンドウハンドル, コンボボックスから得る文字列, バッファ長, サンプリング周波数, 
% 	*          インプットレイテンシ, アウトプットレイテンシ
% 	*/
% 	////////////////////////
% 	// 変数をms単位に変換
% 	//////////////////////////
% 	TCHAR NumberOfloopsInfo[LENSTR];
% 	// 入力レイテンシー（バッファ2個分の時間を減算）
% 	double inlatency_ms = (double)inlatency * 1000.0 / (double)rate - (double)lenbuffer * 2.0 * 1000.0 / (double)rate;
% 	// 出力レイテンシー
% 	double outlatency_ms = (double)outlatency * 1000.0 / (double)rate;
% 	// マイコンでの遅延
% 	double kairo = (double)KAIROLATE;

% 	// NumberOfloopsの計算
% 	*NumberOfloops = ((double)Num - (inlatency_ms + outlatency_ms + kairo)) * (double)rate / ((double)lenbuffer * 1000.0);

% 	// NumberOfloops == 0のとき、1に更新
% 	if (*NumberOfloops < 1) *NumberOfloops = 1;


% 	////メッセージボックスへの出力
% 	//_stprintf_s(NumberOfloopsInfo, LENSTR,
% 	//	_T("入力レイテンシ: %f [ms]\n"
% 	//	"出力レイテンシ: %f [ms]\n"
% 	//	"入出力レイテンシ: %f [ms]\n"
% 	//	"遅延させたい時間: %d [ms]\n"
% 	//	"回路による遅延: %f [ms]\n"
% 	//	"バッファ長: %d [points]\n"
% 	//	"Fs: %d [Hz]\n"
% 	//	"NumberOfloops = %d\n"
% 	//	"NumberOfloops(double) = %f"),
% 	//	inlatency_ms, outlatency_ms, inlatency_ms + outlatency_ms, Num, kairo, lenbuffer, rate, *NumberOfloops,
% 	//	((double)Num - (inlatency_ms + outlatency_ms + kairo)) * (double)rate / ((double)lenbuffer * 1000.0));

% 	//MessageBox(hwnd, NumberOfloopsInfo, _T("計算結果"), MB_OK);

% 	return true;

% }

% // エディットボックスを自動的に下までスクロールする
% bool ScrollToBottom(HWND hEditBox) {
% 	// エディットボックス内の文字列の長さを取得
% 	int len = GetWindowTextLength(hEditBox);
% 	// 何も選択せずにエディットボックス内のテキストの最後にキャレットを移動
% 	SendMessage(hEditBox, EM_SETSEL, (WPARAM)len, (LPARAM)len);
% 	// エディットボックスをカーソルまでスクロールする
% 	SendMessage(hEditBox, EM_SCROLLCARET, 0, 0);

% 	return true;
% }

% // 被験者情報をベクタに保存
% bool GetEditBoxTextFunc(HWND hwnd) {
% 	char* lpstringOld = new char[10];
% 	char* lpstringName = new char[50];

% 	GetWindowText(GetDlgItem(hwnd, ID_EDIT_OLD), lpstringOld, 10);
% 	GetWindowText(GetDlgItem(hwnd, ID_EDIT_NAME), lpstringName, 50);

% 	string Old = lpstringOld;
% 	string Name = lpstringName;

% 	MarginTime.insert(MarginTime.begin(), Old);
% 	MarginTime.insert(MarginTime.begin(), Name);

% 	delete[] lpstringOld;
% 	delete[] lpstringName;

% 	return true;
% }

% bool OnPaint(HWND hWnd, HDC hdc) {
% 	HPEN hBluePen = CreatePen(PS_SOLID, 5, (RGB(0, 150, 215)));
% 	RECT rButtonSendCSV = {rGroupIni.left + 294 , 374, rGroupIni.left + 294  + rGroupIni2.right - rGroupIni2.left + 52, 373 + 52
% 	};
% 	HPEN hOldPen = (HPEN)SelectObject(hdc, hBluePen);
% 	Rectangle(hdc, rButtonSendCSV.left, rButtonSendCSV.top, rButtonSendCSV.right, rButtonSendCSV.bottom);
% 	SelectObject(hdc, hOldPen);

% 	DeleteObject(hBluePen);
% 	return true;
% }
% bool OnCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) {

% 	switch (LOWORD(wparam)) {
% 	case ID_ASIOINFORMATION:
% 		//ASIO情報の表示
% 		MessageBox(NULL, strASIOInfo, _T("ASIO"), MB_OK);
% 		break;

% 	case ID_WAVEFILEINFORMATION:
% 		//Waveファイル情報の表示
% 		MessageBox(NULL, strWaveFileInfo, _T("Wave File"), MB_OK);
% 		break;

% 	case ID_EXIT:
% 		//プログラムの終了
% 		if (IDYES == MessageBox(hwnd, _T("終了しますか？"), _T("終了確認"), MB_YESNO)) {
% 			DestroyWindow(hwnd);
% 		}
% 		break;
		
% 		// 遅延時間の設定
% 		// 配列の削除
% 	case ID_MENU_RESTART:
% 		if (MessageBox(hwnd, _T("結果をファイルに書き込みましたか？"), _T("確認"), MB_YESNO) == IDYES) {
% 			if (ClearMarginTime(hwnd, MarginTime)) {
% 				MessageBox(hwnd, _T("結果を削除しました。"), _T("削除完了"), MB_OK);
% 			}
% 			// コンボボックスの有効化
% 			if (!LABNormal)
% 			{
% 				EnableWindow(GetDlgItem(hwnd, ID_EDIT_LATEDATA_TIMING), TRUE);
% 				EnableWindow(GetDlgItem(hwnd, ID_LATEINI_2), TRUE);
% 				EnableWindow(GetDlgItem(hwnd, ID_LATESETTING_2), TRUE);
% 			}
% 			else {
% 				EnableWindow(GetDlgItem(hwnd, ID_LATESETTING), TRUE);        
% 				EnableWindow(GetDlgItem(hParentWindow, ID_LATEINI), TRUE);
% 			}
% 			if (Finished == true) { Finished = false; }
% 		}
% 		break;

% 	case ID_MENU_INI_FILE:
% 		// ファイル選択のためのダイアログボックスを表示
% 	{
% 		bool ReadIniFileFlag = SelectIniFile(hwnd, FileNameINI);
% 		if (ReadIniFileFlag) {
% 			// Iniファイルの更新
% 			ReadIniFile(hwnd, lparam, FileNameINI);
% 			// ループ回数の設定
% 			LateIniFunc(hwnd, wparam);
% 			// ウィンドウに表示されるファイル名の更新
% 			RelativepathFromAbsolutepath(FileNameINI, hwnd, ID_GROUP_LATEDATA, false);
% 			RelativepathFromAbsolutepath(FileNameINI, hwnd, ID_GROUP_LATEDATA_2, true);

% 		}
% 		break;
% 	}
% 	case ID_DELETE_ARRAY:
% 		/*NumberOfloops = 1;
% 		SetWindowText(hStaticNumberOfloops2, _T("1"));*/
% 		if (ClearMarginTime(hwnd, MarginTime)) {
% 			MessageBox(hwnd, _T("結果を削除しました。"), _T("削除完了"), MB_OK);
% 		}
% 		break;
% 		///////////////////
% 		// コンボボックス
% 		///////////////////
% 	case ID_LATEINI:
% 		// 基本情報
% 		if (HIWORD(wparam) == CBN_SELCHANGE) {
% 			SendLate2Combo(hwnd, wparam, FileNameINI);
% 			LateIniFunc(hwnd, wparam);
% 		}
% 		break;
		
% 	case ID_LATESETTING:
% 		// 詳細情報
% 		if (HIWORD(wparam) == CBN_SELCHANGE) {
% 			LateIniFunc(hwnd, wparam);
% 		}
% 		break;		break;
% 		////////////////////
% 		// コンボボックス(変則var)
% 		////////////////////

% 	case ID_LATEINI_2:
% 		// 基本情報(変則var)
% 		if (HIWORD(wparam) == CBN_SELCHANGE) {
% 			SendLate2Combo_2(hwnd, wparam, FileNameINI);
% 			LateIniFunc_2(hwnd, wparam);
% 		}
% 		break;
% 	case ID_LATESETTING_2:
% 		//　詳細情報(変則var)
% 		if (HIWORD(wparam) == CBN_SELCHANGE) {
% 			LateIniFunc_2(hwnd, wparam);
% 		}
% 		break;

% 	// 取得回数の設定
% 	case ID_STATIC_TRIALS_NUM:
% 		if (HIWORD(wparam) == CBN_SELCHANGE) {
% 			int itemIndex = SendMessage(GetDlgItem(hwnd, ID_STATIC_TRIALS_NUM), CB_GETCURSEL, 0, 0);
% 			if (itemIndex != CB_ERR) {
% 				char itemData[10] = {0};
% 				SendMessage(GetDlgItem(hwnd, ID_STATIC_TRIALS_NUM), CB_GETLBTEXT, itemIndex, (LPARAM)itemData);
% 				int Temp = _ttol(itemData);
% 				TempNumberOfTrials = Temp;
% 			}
% 		}
% 		break;
% 		// 実験方法の選択
% 	case ID_STATIC_NORMALORIRREG:
% 		if (HIWORD(wparam) == CBN_SELCHANGE) {
% 			int itemIndex = SendMessage(GetDlgItem(hwnd, ID_STATIC_NORMALORIRREG), CB_GETCURSEL, 0, 0);
% 			if (itemIndex != CB_ERR) {
% 				if (itemIndex) {
% 					/*if (DialogBox(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_MYDIALOG), hwnd, DialogProc) == -1) {
% 						MessageBox(hwnd, _T("ダイアログボックスの作成に失敗しました。"), _T("エラー"), MB_OK);
% 					}*/
% 					EnableWindow(GetDlgItem(hwnd, ID_EDIT_LATEDATA_TIMING), TRUE);
% 					EnableWindow(GetDlgItem(hwnd, ID_LATEINI_2), TRUE);
% 					EnableWindow(GetDlgItem(hwnd, ID_LATESETTING_2), TRUE);
% 					EnableWindow(GetDlgItem(hwnd, ID_LATESETTING), FALSE);
% 					EnableWindow(GetDlgItem(hParentWindow, ID_LATEINI), FALSE);
% 					// 遅延のタイミング
% 					char* lpstringDelayTiming = new char[50];
% 					GetWindowText(GetDlgItem(hwnd, ID_EDIT_LATEDATA_TIMING), lpstringDelayTiming, 50);
% 					DelayTiming = atoi(lpstringDelayTiming);
% 					//コンボボックスで現在選択されている項目のインデックスを取得
% 					int LocalDelayTIme = GetNowComboStr(hwnd, ID_LATESETTING_2);
% 					DelayTime_ms = LocalDelayTIme;

% 					LABNormal = false;
% 					delete[] lpstringDelayTiming;
% 				}
% 				else {
% 					EnableWindow(GetDlgItem(hwnd, ID_EDIT_LATEDATA_TIMING), FALSE);
% 					EnableWindow(GetDlgItem(hwnd, ID_LATEINI_2), FALSE);
% 					EnableWindow(GetDlgItem(hwnd, ID_LATESETTING_2), FALSE);
% 					EnableWindow(GetDlgItem(hwnd, ID_LATESETTING), TRUE);
% 					EnableWindow(GetDlgItem(hParentWindow, ID_LATEINI), TRUE);

% 					DelayTiming = 1;
% 					LABNormal = true;
% 				}
% 			}
% 		}
% 		break;
% 		// BPMの選択
% 	case ID_STATIC_BPMNUM:
% 		if (HIWORD(wparam) == CBN_SELCHANGE) {
% 			int itemIndex = SendMessage(GetDlgItem(hwnd, ID_STATIC_BPMNUM), CB_GETCURSEL, 0, 0);
% 			if (itemIndex != CB_ERR) {
% 				/*BPMの変更に伴う処理をここに書く*/
% 			}
% 		}
% 		break;
% 	////////////////////////////////
% 	// 「メニュー」→「実験方法」
% 	// /////////////////////////////
% 	case ID_MENU_NORMAL:
% 		SetWindowText(GetDlgItem(hParentWindow, ID_STATIC_NORMALORIRREG), _T("通常"));
% 		LABNormal = true;
% 		break;
% 	case ID_MENU_IRREG:
% 		SetWindowText(GetDlgItem(hParentWindow, ID_STATIC_NORMALORIRREG), _T("変則"));
% 		LABNormal = false;
% 		break;
	
% 		///////////////
% 	// ファイルの指定
% 		////////////////
% 	case ID_MENU_CSV_OUTPUT:
% 	{
% 		// ファイル選択用ダイアログの表示
% 		bool MadeFile = SelectFile(hwnd, FileNameCSV);
% 		if (MadeFile)
% 		{
% 			// パス名をstring型に変換
% 			CSVFILENAME = FileNameCSV;
% 			// 出力先ファイルをウィンドウ上に表示
% 			RelativepathFromAbsolutepath(FileNameCSV, hwnd, ID_EDIT_FILEPATH, false);
% 		}
% 	}
% 		break;
% 		// プッシュボタン
% 	case ID_BUTTON_CSV:
% 		if (HIWORD(wparam) == BN_CLICKED) {
% 			Finished = false; // ファイルに書き込んだらtrueにする
% 			// 年齢と名前が書かれているかチェック
% 			short length_1 = GetWindowTextLength(GetDlgItem(hwnd, ID_EDIT_OLD));
% 			short length_2 = GetWindowTextLength(GetDlgItem(hwnd, ID_EDIT_NAME));
% 			if (length_1 * length_2 == 0) {
% 				// Edit Boxが空
% 				MessageBox(hwnd, _T("名前と年齢のどちらか、もしくはその両方が未入力です。"), _T("警告"), MB_OK | MB_ICONWARNING);
% 				break;
% 			}
% 			// 既に開かれているかをチェック
% 			if (!CheckCanWriteFile(hwnd, FileNameCSV)) {
% 				// ファイルを開くのに失敗した場合、書き込みが不可能である可能性が高い
% 				MessageBox(hwnd, _T("ファイルに書き込めません。ファイルが選択されていないか既に開かれている可能性があります。"), _T("警告"), MB_OK | MB_ICONWARNING);
% 				break;
% 			}
% 			// 遅延時間のグループ名とBPMを出力
% 			 // リサイズ。書き込み可能となるようにメモリを確保
% 			string delay_group,bpm;
% 			delay_group.resize(10);  
% 			bpm.resize(10);
% 			// null文字を除いた書き込んだ文字数を返す
% 			int NumWritten=0;
% 			if (!LABNormal) {
% 				NumWritten = GetWindowText(GetDlgItem(hwnd, ID_LATEINI_2), &delay_group[0], sizeof(delay_group));
% 			}else{
% 				NumWritten = GetWindowText(GetDlgItem(hwnd, ID_LATEINI), &delay_group[0], sizeof(delay_group));
% 			}
% 			int NumBpm = GetWindowText(GetDlgItem(hwnd, ID_STATIC_BPMNUM), &bpm[0], sizeof(bpm));
% 			// null文字を除いた要素数にresizeする
% 			delay_group.resize(NumWritten);       
% 			bpm.resize(NumBpm);
			
% 			MarginTime.insert(MarginTime.begin(), bpm);                                // BPMをベクタの先頭に代入
% 			GetEditBoxTextFunc(hParentWindow);                                            // 被験者情報をベクタの先頭に代入
% 			MarginTime.insert(MarginTime.begin(), delay_group);                     // 遅延時間のグループ名をベクタの先頭に代入
% 			MarginTime.insert(MarginTime.begin(), to_string(Num));                 // 遅延時間をベクタの先頭に代入
% 			MarginTime.insert(MarginTime.begin(), TimeStampButtonClicked);   // 押下時刻をベクタの先頭に代入
% 			if (!LABNormal) {
% 				string tempunique = _T("irregular");
% 				string stringDelayTiming = to_string(DelayTiming);
% 				string stringDelayTime_ms = to_string(DelayTime_ms);

% 				// 実験条件が変則の場合、ベクタの先頭に文字列を代入
% 				MarginTime.insert(MarginTime.begin(), stringDelayTiming);        // 遅延のタイミング
% 				MarginTime.insert(MarginTime.begin(), stringDelayTime_ms);    // 遅延時間
% 				MarginTime.insert(MarginTime.begin(), tempunique);                // irregular
% 				EnableWindow(GetDlgItem(hwnd, ID_LATESETTING_2), TRUE);
% 				EnableWindow(GetDlgItem(hParentWindow, ID_LATEINI_2), TRUE);
% 				EnableWindow(GetDlgItem(hParentWindow, ID_EDIT_LATEDATA_TIMING), TRUE);
% 			}
% 			// コンボボックスの更新
% 			// コンボボックスの表示を次の選択肢に更新
% 			//if (LABNormal) {
% 			//	int NumberOfCursel = SendMessage(GetDlgItem(hParentWindow, ID_LATESETTING), CB_GETCOUNT, 0, 0); // 選択肢の数
% 			//	int NowCursel = SendMessage(GetDlgItem(hParentWindow, ID_LATESETTING), CB_GETCURSEL, 0, 0);        // 現在の選択項目
% 			//	if (NowCursel == NumberOfCursel - 1)
% 			//		SendMessage(GetDlgItem(hParentWindow, ID_LATESETTING), CB_SETCURSEL, 0, 0); // 先頭項目に戻す
% 			//	else SendMessage(GetDlgItem(hParentWindow, ID_LATESETTING), CB_SETCURSEL, NowCursel + 1, 0); // 次の項目に更新
% 			//}
% 			//else
% 			//{
% 			//	int NumberOfCursel = SendMessage(GetDlgItem(hParentWindow, ID_LATESETTING_2), CB_GETCOUNT, 0, 0); // 選択肢の数
% 			//	int NowCursel = SendMessage(GetDlgItem(hParentWindow, ID_LATESETTING_2), CB_GETCURSEL, 0, 0);        // 現在の選択項目
% 			//	if (NowCursel == NumberOfCursel - 1)
% 			//		SendMessage(GetDlgItem(hParentWindow, ID_LATESETTING_2), CB_SETCURSEL, 0, 0); // 先頭項目に戻す
% 			//	else SendMessage(GetDlgItem(hParentWindow, ID_LATESETTING_2), CB_SETCURSEL, NowCursel + 1, 0); // 次の項目に更新
% 			//}
% 			WriteToCSV(hwnd, MarginTime, CSVFILENAME);
% 			EnableWindow(GetDlgItem(hwnd, ID_LATESETTING), TRUE);        // コンボボックスの有効化
% 			EnableWindow(GetDlgItem(hParentWindow, ID_LATEINI), TRUE);

% 		}
% 		break;
% 	}

% 	return true;
% }

% // 標準偏差を計算するための関数
% double calculate_unbiased_stddev(const vector<double>& numbers) {

% 	// データの平均値を算出
% 	double ave = 0.0;
% 	for (const auto& num : numbers) {
% 		ave += num;
% 	}
% 	ave /= numbers.size();

% 	double variance = 0.0;
% 	for (const auto& num : numbers) {
% 		variance += (num - ave) * (num - ave);
% 	}
% 	// n-1で割り不偏分散を計算
% 	variance /= (numbers.size() - 1);
	
% 	// 最後に不偏分散の平方根をとる
% 	return sqrt(variance);
% }

% // string vectorから標準偏差を計算するための関数
% bool SetStddev2Window(const vector<string> mTime) {

% 	vector<double> numbers;

% 	// 文字列を数値に変換、vectorに格納
% 	for (const auto& str : mTime) {
% 		if (str == "false" ) {
% 			// "false"だった場合はスキップ
% 			continue;
% 		}
% 		numbers.push_back(stod(str));
% 	}
% 	// 標準偏差を取得
% 	double std_dev = calculate_unbiased_stddev(numbers);
% 	// 小数点以下1桁までに丸める（中間の値（2.5や3.5など）は、最も近い偶数整数に四捨五入される）
% 	std_dev = round(std_dev * 10.0) / 10.0;

% 	// string型の文字列に変換
% 	stringstream ss;
% 	ss << std_dev;
% 	string std_dev_str = ss.str();

% 	// ウィンドウに結果を表示
% 	std_dev_str = _T("Std[ms]: ") + std_dev_str;
% 	SetWindowText(GetDlgItem(hParentWindow, ID_STATIC_STDDEV), std_dev_str.c_str());

% 	return true;
% }
% \end{lstlisting}
